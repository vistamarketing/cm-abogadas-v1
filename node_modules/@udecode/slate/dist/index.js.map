{"version":3,"sources":["../src/index.ts","../src/create-editor.ts","../src/interfaces/element.ts","../src/interfaces/location-ref.ts","../src/interfaces/path.ts","../src/interfaces/location.ts","../src/interfaces/node.ts","../src/internal/editor-extension/node-extension.ts","../src/interfaces/text.ts","../src/interfaces/operation.ts","../src/interfaces/point.ts","../src/interfaces/range.ts","../src/internal/dom-editor/blur.ts","../src/internal/dom-editor/deselectDOM.ts","../src/internal/dom-editor/findDocumentOrShadowRoot.ts","../src/internal/dom-editor/findEventRange.ts","../src/internal/dom-editor/findKey.ts","../src/internal/dom-editor/findPath.ts","../src/internal/dom-editor/focus.ts","../src/internal/dom-editor/getWindow.ts","../src/internal/dom-editor/hasDOMNode.ts","../src/internal/dom-editor/hasEditableTarget.ts","../src/internal/dom-editor/hasRange.ts","../src/internal/dom-editor/hasSelectableTarget.ts","../src/internal/dom-editor/hasTarget.ts","../src/internal/dom-editor/isComposing.ts","../src/internal/dom-editor/isFocused.ts","../src/internal/dom-editor/isReadOnly.ts","../src/internal/dom-editor/isTargetInsideNonReadonlyVoid.ts","../src/internal/dom-editor/toDOMNode.ts","../src/internal/dom-editor/toDOMPoint.ts","../src/internal/dom-editor/toDOMRange.ts","../src/internal/dom-editor/toSlateNode.ts","../src/internal/dom-editor/toSlatePoint.ts","../src/internal/dom-editor/toSlateRange.ts","../src/internal/editor-extension/edge-blocks.ts","../src/internal/editor-extension/editor-block.ts","../src/internal/editor-extension/editor-blocks.ts","../src/utils/assignLegacyTransforms.ts","../src/utils/deleteMerge.ts","../src/internal/editor/createPathRef.ts","../src/internal/editor/createPointRef.ts","../src/internal/editor/getEndPoint.ts","../src/utils/getAt.ts","../src/internal/editor/getLeafNode.ts","../src/internal/editor/getPointAfter.ts","../src/internal/editor/getPointBefore.ts","../src/internal/editor/getStartPoint.ts","../src/internal/editor/getVoidNode.ts","../src/internal/editor/isBlock.ts","../src/utils/match.ts","../src/internal/editor/nodes.ts","../src/internal/editor/withoutNormalizing.ts","../src/internal/transforms/select.ts","../src/utils/queryEditor.ts","../src/utils/queryNode.ts","../src/internal/editor-extension/editor-descendant.ts","../src/internal/editor-extension/editor-mark.ts","../src/internal/editor-extension/hasMark.ts","../src/internal/editor-extension/is-selected.ts","../src/internal/editor-extension/isAt.ts","../src/internal/editor-extension/isEditorEnd.ts","../src/internal/editor-extension/isText.ts","../src/internal/editor-extension/nodes-range.ts","../src/internal/editor-extension/prop.ts","../../../node_modules/compute-scroll-into-view/src/index.ts","../../../node_modules/scroll-into-view-if-needed/src/index.ts","../src/internal/editor-extension/scrollIntoView.ts","../src/internal/editor-extension/some.ts","../src/internal/editor/above.ts","../src/internal/editor/addMark.ts","../src/internal/editor/createRangeRef.ts","../src/internal/editor/deleteBackward.ts","../src/internal/editor/deleteForward.ts","../src/internal/editor/deleteFragment.ts","../src/internal/editor/editor-node.ts","../src/internal/editor/editor-path.ts","../src/internal/editor/getEdgePoints.ts","../src/internal/editor/getEditorString.ts","../src/internal/editor/getFirstNode.ts","../src/internal/editor/getFragment.ts","../src/internal/editor/getLevels.ts","../src/internal/editor/getMarks.ts","../src/internal/editor/getPathRefs.ts","../src/internal/editor/getPoint.ts","../src/internal/editor/getPointRefs.ts","../src/internal/editor/getPositions.ts","../src/internal/editor/getRangeRefs.ts","../src/internal/editor/hasBlocks.ts","../src/internal/editor/hasInlines.ts","../src/internal/editor/hasTexts.ts","../src/internal/editor/insertBreak.ts","../src/internal/editor/insertNode.ts","../src/internal/editor/isEdgePoint.ts","../src/internal/editor/isEditorNormalizing.ts","../src/internal/editor/isElementReadOnly.ts","../src/internal/editor/isEmpty.ts","../src/internal/editor/isEndPoint.ts","../src/internal/editor/isStartPoint.ts","../src/internal/editor/last.ts","../src/internal/editor/next.ts","../src/internal/editor/normalizeEditor.ts","../src/internal/editor/parent.ts","../src/internal/editor/previous.ts","../src/internal/editor/range.ts","../src/internal/editor/removeEditorMark.ts","../src/internal/editor/unhangRange.ts","../src/internal/transforms-extension/addMarks.ts","../src/internal/transforms-extension/duplicateNodes.ts","../src/internal/transforms-extension/removeMarks.ts","../src/internal/transforms-extension/replaceNodes.ts","../src/internal/transforms-extension/reset.ts","../src/internal/transforms-extension/toggleBlock.ts","../src/internal/transforms-extension/toggleMark.ts","../src/internal/transforms/collapseSelection.ts","../src/internal/transforms/deleteText.ts","../src/internal/transforms/deselect.ts","../src/internal/transforms/insertFragment.ts","../src/internal/transforms/insertNodes.ts","../src/internal/transforms/insertText.ts","../src/internal/transforms/liftNodes.ts","../src/internal/transforms/mergeNodes.ts","../src/internal/transforms/moveNodes.ts","../src/internal/transforms/moveSelection.ts","../src/internal/transforms/removeNodes.ts","../src/internal/transforms/setNodes.ts","../src/internal/transforms/setPoint.ts","../src/internal/transforms/setSelection.ts","../src/internal/transforms/splitNodes.ts","../src/internal/transforms/unsetNodes.ts","../src/internal/transforms/unwrapNodes.ts","../src/internal/transforms/wrapNodes.ts","../src/slate-history/history.ts","../src/slate-dom.ts","../src/slate-history/with-history.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './create-editor';\nexport * from './slate-dom';\nexport * from './types';\nexport * from './interfaces/index';\nexport * from './slate-history/index';\nexport * from './utils/index';\n","import { bindFirst } from '@udecode/utils';\nimport {\n  apply,\n  createEditor as createSlateEditor,\n  getDirtyPaths,\n  hasPath,\n  insertSoftBreak,\n  normalizeNode,\n  setNormalizing,\n  shouldMergeNodesRemovePrevNode,\n  shouldNormalize,\n} from 'slate';\n\nimport type { Editor, Value } from './interfaces/editor/editor-type';\n\nimport {\n  type EditorApi,\n  type LegacyEditorMethods,\n  RangeApi,\n} from './interfaces';\nimport { blur } from './internal/dom-editor/blur';\nimport { deselectDOM } from './internal/dom-editor/deselectDOM';\nimport { findDocumentOrShadowRoot } from './internal/dom-editor/findDocumentOrShadowRoot';\nimport { findEventRange } from './internal/dom-editor/findEventRange';\nimport { findKey } from './internal/dom-editor/findKey';\nimport { findPath } from './internal/dom-editor/findPath';\nimport { focus } from './internal/dom-editor/focus';\nimport { getWindow } from './internal/dom-editor/getWindow';\nimport { hasDOMNode } from './internal/dom-editor/hasDOMNode';\nimport { hasEditableTarget } from './internal/dom-editor/hasEditableTarget';\nimport { hasRange } from './internal/dom-editor/hasRange';\nimport { hasSelectableTarget } from './internal/dom-editor/hasSelectableTarget';\nimport { hasTarget } from './internal/dom-editor/hasTarget';\nimport { isComposing } from './internal/dom-editor/isComposing';\nimport { isFocused } from './internal/dom-editor/isFocused';\nimport { isReadOnly } from './internal/dom-editor/isReadOnly';\nimport { isTargetInsideNonReadonlyVoid } from './internal/dom-editor/isTargetInsideNonReadonlyVoid';\nimport { toDOMNode } from './internal/dom-editor/toDOMNode';\nimport { toDOMPoint } from './internal/dom-editor/toDOMPoint';\nimport { toDOMRange } from './internal/dom-editor/toDOMRange';\nimport { toSlateNode } from './internal/dom-editor/toSlateNode';\nimport { toSlatePoint } from './internal/dom-editor/toSlatePoint';\nimport { toSlateRange } from './internal/dom-editor/toSlateRange';\nimport { edgeBlocks } from './internal/editor-extension/edge-blocks';\nimport { block } from './internal/editor-extension/editor-block';\nimport { blocks } from './internal/editor-extension/editor-blocks';\nimport { descendant } from './internal/editor-extension/editor-descendant';\nimport { mark } from './internal/editor-extension/editor-mark';\nimport { hasMark } from './internal/editor-extension/hasMark';\nimport { isSelected } from './internal/editor-extension/is-selected';\nimport { isAt } from './internal/editor-extension/isAt';\nimport { isEditorEnd } from './internal/editor-extension/isEditorEnd';\nimport { isText } from './internal/editor-extension/isText';\nimport { nodesRange } from './internal/editor-extension/nodes-range';\nimport { prop } from './internal/editor-extension/prop';\nimport { scrollIntoView } from './internal/editor-extension/scrollIntoView';\nimport { some } from './internal/editor-extension/some';\nimport { above } from './internal/editor/above';\nimport { addMark } from './internal/editor/addMark';\nimport { createPathRef } from './internal/editor/createPathRef';\nimport { createPointRef } from './internal/editor/createPointRef';\nimport { createRangeRef } from './internal/editor/createRangeRef';\nimport { deleteBackward } from './internal/editor/deleteBackward';\nimport { deleteForward } from './internal/editor/deleteForward';\nimport { deleteFragment } from './internal/editor/deleteFragment';\nimport { node } from './internal/editor/editor-node';\nimport { path } from './internal/editor/editor-path';\nimport { getEdgePoints } from './internal/editor/getEdgePoints';\nimport { getEditorString } from './internal/editor/getEditorString';\nimport { getEndPoint } from './internal/editor/getEndPoint';\nimport { getFirstNode } from './internal/editor/getFirstNode';\nimport { getFragment } from './internal/editor/getFragment';\nimport { getLeafNode } from './internal/editor/getLeafNode';\nimport { getLevels } from './internal/editor/getLevels';\nimport { getMarks } from './internal/editor/getMarks';\nimport { getPathRefs } from './internal/editor/getPathRefs';\nimport { getPoint } from './internal/editor/getPoint';\nimport { getPointAfter } from './internal/editor/getPointAfter';\nimport { getPointBefore } from './internal/editor/getPointBefore';\nimport { getPointRefs } from './internal/editor/getPointRefs';\nimport { getPositions } from './internal/editor/getPositions';\nimport { getRangeRefs } from './internal/editor/getRangeRefs';\nimport { getStartPoint } from './internal/editor/getStartPoint';\nimport { getVoidNode } from './internal/editor/getVoidNode';\nimport { hasBlocks } from './internal/editor/hasBlocks';\nimport { hasInlines } from './internal/editor/hasInlines';\nimport { hasTexts } from './internal/editor/hasTexts';\nimport { insertBreak } from './internal/editor/insertBreak';\nimport { insertNode } from './internal/editor/insertNode';\nimport { isBlock } from './internal/editor/isBlock';\nimport { isEdgePoint } from './internal/editor/isEdgePoint';\nimport { isEditorNormalizing } from './internal/editor/isEditorNormalizing';\nimport { isElementReadOnly } from './internal/editor/isElementReadOnly';\nimport { isEmpty } from './internal/editor/isEmpty';\nimport { isEndPoint } from './internal/editor/isEndPoint';\nimport { isStartPoint } from './internal/editor/isStartPoint';\nimport { last } from './internal/editor/last';\nimport { next } from './internal/editor/next';\nimport { nodes } from './internal/editor/nodes';\nimport { normalizeEditor } from './internal/editor/normalizeEditor';\nimport { parent } from './internal/editor/parent';\nimport { previous } from './internal/editor/previous';\nimport { range } from './internal/editor/range';\nimport { removeEditorMark } from './internal/editor/removeEditorMark';\nimport { unhangRange } from './internal/editor/unhangRange';\nimport { withoutNormalizing } from './internal/editor/withoutNormalizing';\nimport { addMarks } from './internal/transforms-extension/addMarks';\nimport { duplicateNodes } from './internal/transforms-extension/duplicateNodes';\nimport { removeMarks } from './internal/transforms-extension/removeMarks';\nimport { replaceNodes } from './internal/transforms-extension/replaceNodes';\nimport { reset } from './internal/transforms-extension/reset';\nimport { toggleBlock } from './internal/transforms-extension/toggleBlock';\nimport { toggleMark } from './internal/transforms-extension/toggleMark';\nimport { collapseSelection } from './internal/transforms/collapseSelection';\nimport { deleteText } from './internal/transforms/deleteText';\nimport { deselect } from './internal/transforms/deselect';\nimport { insertFragment } from './internal/transforms/insertFragment';\nimport { insertNodes } from './internal/transforms/insertNodes';\nimport { insertText } from './internal/transforms/insertText';\nimport { liftNodes } from './internal/transforms/liftNodes';\nimport { mergeNodes } from './internal/transforms/mergeNodes';\nimport { moveNodes } from './internal/transforms/moveNodes';\nimport { moveSelection } from './internal/transforms/moveSelection';\nimport { removeNodes } from './internal/transforms/removeNodes';\nimport { select } from './internal/transforms/select';\nimport { setNodes } from './internal/transforms/setNodes';\nimport { setPoint } from './internal/transforms/setPoint';\nimport { setSelection } from './internal/transforms/setSelection';\nimport { splitNodes } from './internal/transforms/splitNodes';\nimport { unsetNodes } from './internal/transforms/unsetNodes';\nimport { unwrapNodes } from './internal/transforms/unwrapNodes';\nimport { wrapNodes } from './internal/transforms/wrapNodes';\nimport { HistoryApi } from './slate-history/history';\nimport { syncLegacyMethods } from './utils/assignLegacyTransforms';\n\nconst noop: {\n  (name: string): () => void;\n  <T>(name: string, returnValue: T): () => T;\n} =\n  <T>(name: string, returnValue?: T) =>\n  () => {\n    console.warn(\n      `[OVERRIDE_MISSING] The method editor.${name}() has not been implemented or overridden. ` +\n        `This may cause unexpected behavior. Please ensure that all required editor methods are properly defined.`\n    );\n\n    return returnValue;\n  };\n\nexport const createEditor = <V extends Value>({\n  children,\n  selection,\n}: {\n  children?: V;\n  selection?: Editor['selection'];\n} = {}) => {\n  const editor = createSlateEditor() as any as Editor & LegacyEditorMethods;\n\n  if (children) {\n    editor.children = children;\n  }\n  if (selection) {\n    editor.selection = selection;\n  }\n\n  Object.assign(editor, {\n    apply: bindFirst(apply, editor as any),\n    isElementReadOnly: editor.isElementReadOnly,\n    isInline: editor.isInline,\n    isSelectable: editor.isSelectable,\n    isVoid: editor.isVoid,\n    markableVoid: editor.markableVoid,\n    onChange: editor.onChange,\n  });\n\n  Object.assign(editor, {\n    addMark: bindFirst(addMark, editor),\n    deleteBackward: bindFirst(deleteBackward, editor),\n    deleteForward: bindFirst(deleteForward, editor),\n    deleteFragment: bindFirst(deleteFragment, editor),\n    getDirtyPaths: bindFirst(getDirtyPaths, editor as any),\n    getFragment: bindFirst(getFragment, editor),\n    insertBreak: bindFirst(insertBreak, editor),\n    insertFragment: bindFirst(insertFragment, editor),\n    insertNode: bindFirst(insertNode, editor),\n    insertSoftBreak: bindFirst(insertSoftBreak, editor as any),\n    insertText: bindFirst(insertText, editor),\n    normalizeNode: bindFirst(normalizeNode, editor as any),\n    removeMark: bindFirst(removeEditorMark, editor as any),\n    shouldNormalize: bindFirst(shouldNormalize, editor as any),\n  });\n\n  Object.assign(editor, {\n    above: bindFirst(above, editor),\n    after: bindFirst(getPointAfter, editor),\n    before: bindFirst(getPointBefore, editor),\n    collapse: bindFirst(collapseSelection, editor),\n    delete: bindFirst(deleteText, editor),\n    deselect: bindFirst(deselect, editor),\n    deselectDOM: bindFirst(deselectDOM, editor),\n    edges: bindFirst(getEdgePoints, editor),\n    elementReadOnly: bindFirst(isElementReadOnly, editor),\n    end: bindFirst(getEndPoint, editor),\n    first: bindFirst(getFirstNode, editor),\n    fragment: bindFirst(getFragment, editor),\n    getMarks: bindFirst(getMarks, editor),\n    hasBlocks: bindFirst(hasBlocks, editor),\n    hasInlines: bindFirst(hasInlines, editor),\n    hasPath: bindFirst(hasPath, editor as any),\n    hasTexts: bindFirst(hasTexts, editor),\n    insertNodes: bindFirst(insertNodes, editor),\n    isBlock: bindFirst(isBlock, editor),\n    isEdge: bindFirst(isEdgePoint, editor),\n    isEmpty: bindFirst(isEmpty, editor),\n    isEnd: bindFirst(isEndPoint, editor),\n    isNormalizing: bindFirst(isEditorNormalizing, editor),\n    isStart: bindFirst(isStartPoint, editor),\n    last: bindFirst(last, editor),\n    leaf: bindFirst(getLeafNode, editor),\n    levels: bindFirst(getLevels, editor),\n    liftNodes: bindFirst(liftNodes, editor),\n    mergeNodes: bindFirst(mergeNodes, editor),\n    move: bindFirst(moveSelection, editor),\n    moveNodes: bindFirst(moveNodes, editor),\n    next: bindFirst(next, editor),\n    node: bindFirst(node, editor),\n    nodes: bindFirst(nodes, editor),\n    normalize: bindFirst(normalizeEditor, editor),\n    parent: bindFirst(parent, editor),\n    path: bindFirst(path, editor),\n    pathRef: bindFirst(createPathRef, editor),\n    pathRefs: bindFirst(getPathRefs, editor),\n    point: bindFirst(getPoint, editor),\n    pointRef: bindFirst(createPointRef, editor),\n    pointRefs: bindFirst(getPointRefs, editor),\n    positions: bindFirst(getPositions, editor),\n    previous: bindFirst(previous, editor),\n    range: bindFirst(range, editor),\n    rangeRef: bindFirst(createRangeRef, editor),\n    rangeRefs: bindFirst(getRangeRefs, editor),\n    removeNodes: bindFirst(removeNodes, editor),\n    select: bindFirst(select, editor),\n    setNodes: bindFirst(setNodes, editor),\n    setNormalizing: bindFirst(setNormalizing, editor as any),\n    setPoint: bindFirst(setPoint, editor),\n    setSelection: bindFirst(setSelection, editor),\n    shouldMergeNodesRemovePrevNode: bindFirst(\n      shouldMergeNodesRemovePrevNode,\n      editor as any\n    ),\n    splitNodes: bindFirst(splitNodes, editor),\n    start: bindFirst(getStartPoint, editor),\n    string: bindFirst(getEditorString, editor),\n    unhangRange: bindFirst(unhangRange, editor),\n    unsetNodes: bindFirst(unsetNodes, editor),\n    unwrapNodes: bindFirst(unwrapNodes, editor),\n    void: bindFirst(getVoidNode, editor),\n    withoutNormalizing: bindFirst(withoutNormalizing, editor as any),\n    wrapNodes: bindFirst(wrapNodes, editor),\n  });\n\n  Object.assign(editor, {\n    history: { redos: [], undos: [] },\n    redo: noop('redo'),\n    undo: noop('undo'),\n    writeHistory: noop('writeHistory'),\n  });\n\n  Object.assign(editor, {\n    insertData: noop('insertData'),\n    insertFragmentData: noop('insertFragmentData', false),\n    insertTextData: noop('insertTextData', false),\n    setFragmentData: noop('setFragmentData'),\n  });\n\n  const api: Partial<EditorApi<V>> = {\n    block: bindFirst(block, editor) as any,\n    blocks: bindFirst(blocks, editor) as any,\n    create: {\n      block: (props) => ({ children: [{ text: '' }], type: 'p', ...props }),\n      value: () => [api.create!.block()],\n    },\n    descendant: bindFirst(descendant, editor) as any,\n    edgeBlocks: bindFirst(edgeBlocks, editor) as any,\n    findDocumentOrShadowRoot: bindFirst(findDocumentOrShadowRoot, editor),\n    findEventRange: bindFirst(findEventRange, editor),\n    findKey: bindFirst(findKey, editor),\n    findPath: bindFirst(findPath, editor),\n    getWindow: bindFirst(getWindow, editor),\n    hasDOMNode: bindFirst(hasDOMNode, editor),\n    hasEditableTarget: bindFirst(hasEditableTarget, editor) as any,\n    hasMark: bindFirst(hasMark, editor) as any,\n    hasRange: bindFirst(hasRange, editor),\n    hasSelectableTarget: bindFirst(hasSelectableTarget, editor) as any,\n    hasTarget: bindFirst(hasTarget, editor) as any,\n    isAt: bindFirst(isAt, editor),\n    isComposing: bindFirst(isComposing, editor),\n    isEditorEnd: bindFirst(isEditorEnd, editor),\n    isFocused: bindFirst(isFocused, editor),\n    isMerging: bindFirst(HistoryApi.isMerging, editor as any) as any,\n    isReadOnly: bindFirst(isReadOnly, editor),\n    isSaving: bindFirst(HistoryApi.isSaving, editor as any) as any,\n    isSelected: bindFirst(isSelected, editor),\n    isSplittingOnce: bindFirst(HistoryApi.isSplittingOnce, editor as any),\n    isTargetInsideNonReadonlyVoid: bindFirst(\n      isTargetInsideNonReadonlyVoid,\n      editor\n    ),\n    isText: bindFirst(isText, editor),\n    mark: bindFirst(mark, editor) as any,\n    nodesRange: bindFirst(nodesRange, editor),\n    prop: prop as any,\n    scrollIntoView: bindFirst(scrollIntoView, editor),\n    some: bindFirst(some, editor),\n    toDOMNode: bindFirst(toDOMNode, editor),\n    toDOMPoint: bindFirst(toDOMPoint, editor),\n    toDOMRange: bindFirst(toDOMRange, editor),\n    toSlateNode: bindFirst(toSlateNode, editor) as any,\n    toSlatePoint: bindFirst(toSlatePoint, editor),\n    toSlateRange: bindFirst(toSlateRange, editor),\n    isCollapsed: () => RangeApi.isCollapsed(editor.selection),\n    isExpanded: () => RangeApi.isExpanded(editor.selection),\n    shouldNormalizeNode: () => true,\n  };\n\n  const transforms: Partial<Editor<V>['transforms']> = {\n    addMarks: bindFirst(addMarks, editor),\n    blur: bindFirst(blur, editor),\n    deselectDOM: bindFirst(deselectDOM, editor),\n    duplicateNodes: bindFirst(duplicateNodes, editor),\n    focus: bindFirst(focus, editor),\n    removeMarks: bindFirst(removeMarks, editor as any),\n    replaceNodes: bindFirst(replaceNodes, editor) as any,\n    reset: bindFirst(reset, editor),\n    setSplittingOnce: bindFirst(HistoryApi.setSplittingOnce, editor as any),\n    toggleBlock: bindFirst(toggleBlock, editor),\n    toggleMark: bindFirst(toggleMark, editor as any),\n    withMerging: bindFirst(HistoryApi.withMerging, editor as any),\n    withNewBatch: bindFirst(HistoryApi.withNewBatch, editor as any),\n    withoutMerging: bindFirst(HistoryApi.withoutMerging, editor as any),\n    withoutSaving: bindFirst(HistoryApi.withoutSaving, editor as any),\n  };\n\n  editor.api = api as any;\n  editor.tf = transforms as any;\n  editor.transforms = transforms as any;\n\n  syncLegacyMethods(editor);\n\n  return editor as unknown as Editor<V>;\n};\n","import type { UnknownObject } from '@udecode/utils';\n\nimport { Element as SlateElement } from 'slate';\n\nimport type { Editor, Value } from './editor';\nimport type { Ancestor, Descendant, TNode } from './node';\nimport type { TextIn, TextOf } from './text';\n\n/**\n * `TElement` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\nexport type TElement = {\n  children: Descendant[];\n  type: string;\n} & UnknownObject;\n\n/** Element retrieval and check methods. */\nexport const ElementApi: {\n  /** Check if a value implements the 'Ancestor' interface. */\n  isAncestor: <T extends Ancestor>(value: any) => value is T;\n  /** Check if a value implements the `TElement` interface. */\n  isElement: <T extends TElement>(value: any) => value is T;\n  /** Check if a value is an array of `TElement` objects. */\n  isElementList: <T extends TElement>(value: any) => value is T[];\n  /** Check if a set of props is a partial of TElement. */\n  isElementProps: <T extends TElement>(props: any) => props is Partial<T>;\n  /**\n   * Check if a value implements the `TElement` interface and has elementKey\n   * with selected value. Default it check to `type` key value\n   */\n  isElementType: <T extends TElement>(\n    value: any,\n    elementVal: string,\n    elementKey?: string\n  ) => value is T;\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n  matches: (element: TElement, props: Partial<TElement>) => boolean;\n} = {\n  ...(SlateElement as any),\n};\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\nexport type Element = TElement;\n\n/** A utility type to get all the element nodes type from a root node. */\nexport type ElementIn<V extends Value> = ElementOf<V[number]>;\n\nexport type ElementOf<N extends TNode> = Editor extends N\n  ? TElement\n  : TElement extends N\n    ? TElement\n    : N extends Editor\n      ?\n          | ElementOf<N['children'][number]>\n          | Extract<N['children'][number], TElement>\n      : N extends TElement\n        ?\n            | ElementOf<N['children'][number]>\n            | Extract<N['children'][number], TElement>\n            | N\n        : never;\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n// export type ElementEntry = [TElement, Path];\n\n/** Element or text of an editor. */\nexport type ElementOrTextIn<V extends Value> = ElementIn<V> | TextIn<V>;\n\nexport type ElementOrTextOf<E extends Editor> = ElementOf<E> | TextOf<E>;\n","import { PointRef as SlatePointRef, RangeRef as SlateRangeRef } from 'slate';\n\nimport type { TextDirection } from '../types';\nimport type { Operation } from './operation';\nimport type { Point } from './point';\nimport type { TRange } from './range';\n\nimport { type Path, PathApi } from './path';\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\nexport type PathRef = {\n  affinity: 'backward' | 'forward' | null;\n  current: Path | null;\n  unref: () => Path | null;\n};\n\nexport const PathRefApi: {\n  /** Transform the path ref's current value by an operation. */\n  transform: (ref: PathRef, op: Operation) => void;\n} = {\n  transform(ref, op) {\n    const { affinity, current } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    const path = PathApi.transform(current, op, { affinity });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  },\n};\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as\n * new operations are applied to the editor. You can access their `current`\n * property at any time for the up-to-date point value.\n */\nexport type PointRef = {\n  affinity: TextDirection | null;\n  current: Point | null;\n  unref: () => Point | null;\n};\n\nexport const PointRefApi: {\n  /** Transform the point ref's current value by an operation. */\n  transform: (ref: PointRef, op: Operation) => void;\n} = SlatePointRef as any;\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as\n * new operations are applied to the editor. You can access their `current`\n * property at any time for the up-to-date range value.\n */\nexport type RangeRef = {\n  affinity: 'backward' | 'forward' | 'inward' | 'outward' | null;\n  current: TRange | null;\n  unref: () => TRange | null;\n};\n\nexport const RangeRefApi: {\n  /** Transform the range ref's current value by an operation. */\n  transform: (ref: RangeRef, op: Operation) => void;\n} = SlateRangeRef as any;\n","import { Path as SlatePath } from 'slate';\n\nimport type {\n  InsertNodeOperation,\n  MergeNodeOperation,\n  MoveNodeOperation,\n  Operation,\n  RemoveNodeOperation,\n  SplitNodeOperation,\n} from '../interfaces/operation';\nimport type { TextDirection } from '../types';\nimport type { Descendant } from './node';\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\nexport type Path = number[];\n\n/** Path retrieval, check and transform methods. */\nexport const PathApi: {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n  ancestors: (path: Path, options?: PathAncestorsOptions) => Path[];\n  /** Get a path to a child at the given index. */\n  child: (path: Path, index: number) => Path;\n  /** Get the common ancestor path of two paths. */\n  common: (path: Path, another: Path) => Path;\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[PathApi.equals]] instead.\n   */\n  compare: (path: Path, another: Path) => -1 | 0 | 1;\n  /** Check if a path ends after one of the indexes in another. */\n  endsAfter: (path: Path, another: Path) => boolean;\n  /** Check if a path ends at one of the indexes in another. */\n  endsAt: (path: Path, another: Path) => boolean;\n  /** Check if a path ends before one of the indexes in another. */\n  endsBefore: (path: Path, another: Path) => boolean;\n  /** Check if a path is exactly equal to another. */\n  equals: (path: Path, another: Path) => boolean;\n  /** Get a path to the first child of a path. */\n  firstChild: (path: Path) => Path;\n  /** Check if the path of previous sibling node exists */\n  hasPrevious: (path: Path) => boolean;\n  /** Check if a path is after another. */\n  isAfter: (path: Path, another: Path) => boolean;\n  /** Check if a path is an ancestor of another. */\n  isAncestor: (path: Path, another: Path) => boolean;\n  /** Check if a path is before another. */\n  isBefore: (path: Path, another: Path) => boolean;\n  /** Check if a path is a child of another. */\n  isChild: (path: Path, another: Path) => boolean;\n  /** Check if a path is equal to or an ancestor of another. */\n  isCommon: (path: Path, another: Path) => boolean;\n  /** Check if a path is a descendant of another. */\n  isDescendant: (path: Path, another: Path) => boolean;\n  /** Check if a path is the parent of another. */\n  isParent: (path: Path, another: Path) => boolean;\n  /** Check is a value implements the `Path` interface. */\n  isPath: (value: any) => value is Path;\n  /** Check if a path is a sibling of another. */\n  isSibling: (path: Path, another: Path) => boolean;\n  /** Get the last index of a path. Returns -1 if path is empty. */\n  lastIndex: (path: Path) => number;\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `PathApi.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n  levels: (path: Path, options?: PathLevelsOptions) => Path[];\n  /** Given a path, get the path to the next sibling node. */\n  next: (path: Path) => Path;\n  /**\n   * Returns whether this operation can affect paths or not. Used as an\n   * optimization when updating dirty paths during normalization\n   *\n   * NOTE: This _must_ be kept in sync with the implementation of 'transform'\n   * below\n   */\n  operationCanTransformPath: <N extends Descendant>(\n    operation: Operation<N>\n  ) => operation is\n    | InsertNodeOperation<N>\n    | MergeNodeOperation<N>\n    | MoveNodeOperation\n    | RemoveNodeOperation<N>\n    | SplitNodeOperation<N>;\n  /** Given a path, return a new path referring to the parent node above it. */\n  parent: (path: Path) => Path;\n  /** Given a path, get the path to the previous sibling node. */\n  previous: (path: Path) => Path | undefined;\n  /** Get a path relative to an ancestor. */\n  relative: (path: Path, ancestor: Path) => Path;\n  /** Transform a path by an operation. */\n  transform: (\n    path: Path,\n    operation: Operation,\n    options?: PathTransformOptions\n  ) => Path | null;\n} = {\n  ...(SlatePath as any),\n  child: (path, index) => path.concat([index]),\n  firstChild: (path) => PathApi.child(path, 0),\n  lastIndex: (path) => path.at(-1) ?? -1,\n  next: (path) => {\n    try {\n      return SlatePath.next(path);\n    } catch {\n      return path;\n    }\n  },\n  parent: (path) => {\n    try {\n      return SlatePath.parent(path);\n    } catch {\n      return path;\n    }\n  },\n  previous: (path) => {\n    if (path.length === 0) return;\n\n    const last = path.at(-1)!;\n\n    if (last <= 0) return;\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n} as const;\n\nexport interface PathAncestorsOptions {\n  /** If true, the paths are returned in reverse order. */\n  reverse?: boolean;\n}\n\nexport interface PathLevelsOptions {\n  /** If true, the paths are returned in reverse order. */\n  reverse?: boolean;\n}\n\nexport interface PathTransformOptions {\n  /** The affinity of the transform. */\n  affinity?: TextDirection | null;\n}\n","import { Location as SlateLocation, Span as SlateSpan } from 'slate';\n\nimport type { At } from '../types';\nimport type { Path } from './path';\nimport type { Point } from './point';\nimport type { Range, TRange } from './range';\n\nimport { NodeApi } from './node';\n\n/**\n * The `TLocation` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `TRange`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\nexport type TLocation = Path | Point | TRange;\n\n/** Location check methods. */\nexport const LocationApi: {\n  /** Check if a value implements the `At` interface. */\n  isAt: (value: any) => value is At;\n  /** Check if a value implements the `Location` interface. */\n  isLocation: (value: any) => value is Location;\n} = {\n  ...(SlateLocation as any),\n  isAt: (value) => LocationApi.isLocation(value) || NodeApi.isNode(value),\n};\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\nexport type Span = [Path, Path];\n\nexport const SpanApi: {\n  /** Check if a value implements the `Span` interface. */\n  isSpan: (value: any) => value is Span;\n} = SlateSpan as any;\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\nexport type Location = Path | Point | Range;\n","import { Node as SlateNode } from 'slate';\n\nimport type { Editor, Value } from './editor/editor-type';\nimport type { NodeEntry } from './node-entry';\nimport type { Path } from './path';\nimport type { TRange } from './range';\n\nimport { NodeExtension } from '../internal/editor-extension/node-extension';\nimport { type ElementOf, type TElement, ElementApi } from './element';\nimport { type TextOf, type TText, TextApi } from './text';\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree. It\n * is returned as a convenience in certain cases to narrow a value further than\n * the more generic `Node` union.\n */\nexport type Ancestor = Editor | TElement;\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = TElement | TText;\n\n/** Convenience type for returning the props of a node. */\nexport type NodeProps<N extends TNode = TNode> = N extends Editor\n  ? Omit<N, 'children'>\n  : N extends TElement\n    ? Omit<N, 'children'>\n    : Omit<N, 'text'>;\n\n/**\n * The `TNode` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\nexport type TNode = Editor | TElement | TText;\n\nexport const NodeApi: {\n  /** Get the node at a specific path, asserting that it's an ancestor node. */\n  ancestor: <N extends AncestorOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in the\n   * tree, but you can pass the `reverse: true` option to go top-down.\n   */\n  ancestors: <N extends AncestorOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path,\n    options?: NodeAncestorsOptions\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Get the child of a node at a specific index. */\n  child: <\n    N extends ChildOf<R, I>,\n    R extends TNode = TNode,\n    I extends number = number,\n  >(\n    root: R,\n    index: I\n  ) => N | undefined;\n  /** Iterate over the children of a node at a specific path. */\n  children: <N extends ChildOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path,\n    options?: NodeChildrenOptions\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Get an entry for the common ancestor node of two paths. */\n  common: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path,\n    another: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the node at a specific path, asserting that it's a descendant node. */\n  descendant: <N extends DescendantOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /** Return a generator of all the descendant node entries inside a root node. */\n  descendants: <N extends DescendantOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeDescendantsOptions<R>\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /**\n   * Return a generator of all the element nodes inside a root node. Each\n   * iteration will return an `ElementEntry` tuple consisting of `[Element,\n   * Path]`. If the root node is an element it will be included in the iteration\n   * as well.\n   */\n  elements: <N extends ElementOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeElementsOptions<R>\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Extract props from a TNode. */\n  extractProps: <N extends TNode>(node: N) => NodeProps<N>;\n  /** Get the first node entry in a root node from a path. */\n  first: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the first child node entry of a node. */\n  firstChild: <N extends ChildOf<R, 0>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the first text node entry of a node. */\n  firstText: <N extends TextOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeTextsOptions<R>\n  ) => NodeEntry<N> | undefined;\n  /** Get the sliced fragment represented by a range inside a root node. */\n  fragment: <N extends ElementOf<R> | TextOf<R>, R extends TNode = TNode>(\n    root: R,\n    range: TRange\n  ) => N[];\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n  get: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /** Similar to get, but returns undefined if the node does not exist. */\n  getIf: (root: TNode, path: Path) => TNode | undefined;\n  /** Check if a descendant node exists at a specific path. */\n  has: (root: TNode, path: Path) => boolean;\n  /** Check if a node has a single child */\n  hasSingleChild: (node: TNode) => boolean;\n  /** Check if a value implements the 'Ancestor' interface */\n  isAncestor: <N extends Ancestor>(value: any) => value is N;\n  /** Check if a value implements the 'Descendant' interface. */\n  isDescendant: <N extends Descendant>(value: any) => value is N;\n  /** Check if a value implements the `Editor` interface. */\n  isEditor: (value: any) => value is Editor;\n  /** Check if a node is the last child of its parent. */\n  isLastChild: (root: TNode, path: Path) => boolean;\n  /** Check if a value implements the `TNode` interface. */\n  isNode: <N extends TNode>(value: any) => value is N;\n  /** Check if a value is a list of `Descendant` objects. */\n  isNodeList: <N extends Descendant>(value: any) => value is N[];\n  /** Get the last node entry in a root node from a path. */\n  last: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the last child node entry of a node. */\n  lastChild: <N extends ChildOf<R, -1>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => NodeEntry<N> | undefined;\n  /** Get the node at a specific path, ensuring it's a leaf text node. */\n  leaf: <N extends TextOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from highest to lowest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n  levels: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path,\n    options?: NodeLevelsOptions\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Check if a node matches a set of props. */\n  matches: (node: Descendant, props: Partial<Descendant>) => boolean;\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[TNode, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n  nodes: <N extends NodeOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeNodesOptions<R>\n  ) => Generator<NodeEntry<N>, void, undefined>;\n  /** Get the parent of a node at a specific path. */\n  parent: <N extends AncestorOf<R>, R extends TNode = TNode>(\n    root: R,\n    path: Path\n  ) => N | undefined;\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n  string: (node: TNode) => string;\n  /** Return a generator of all leaf text nodes in a root node. */\n  texts: <N extends TextOf<R>, R extends TNode = TNode>(\n    root: R,\n    options?: NodeTextsOptions<R>\n  ) => Generator<NodeEntry<N>, void, undefined>;\n} = {\n  ...(SlateNode as any),\n  isAncestor: ElementApi.isAncestor,\n  ancestor: (...args) => {\n    try {\n      return SlateNode.ancestor(...args);\n    } catch {}\n  },\n  common: (...args) => {\n    try {\n      return SlateNode.common(...args);\n    } catch {}\n  },\n  descendant: (...args) => {\n    try {\n      return SlateNode.descendant(...args);\n    } catch {}\n  },\n  first: (...args) => {\n    try {\n      return SlateNode.first(...args);\n    } catch {}\n  },\n  fragment: (...args) => {\n    try {\n      return SlateNode.fragment(...args);\n    } catch {\n      return [];\n    }\n  },\n  get: (...args) => {\n    try {\n      return SlateNode.get(...args);\n    } catch {}\n  },\n  hasSingleChild: (node) => {\n    if (TextApi.isText(node)) return true;\n\n    return (\n      node.children.length === 1 && NodeApi.hasSingleChild(node.children[0])\n    );\n  },\n  isDescendant: (node) => ElementApi.isElement(node) || TextApi.isText(node),\n  last: (...args) => {\n    try {\n      return SlateNode.last(...args);\n    } catch {}\n  },\n  leaf: (...args) => {\n    try {\n      return SlateNode.leaf(...args);\n    } catch {}\n  },\n  parent: (...args) => {\n    try {\n      return SlateNode.parent(...args);\n    } catch {}\n  },\n  ...NodeExtension,\n};\n\n/** A utility type to get all the ancestor node types from a root node type. */\nexport type AncestorIn<V extends Value> = AncestorOf<Editor | V[number]>;\n\nexport type AncestorOf<N extends TNode> = Editor extends N\n  ? Editor | TElement\n  : TElement extends N\n    ? TElement\n    : N extends Editor\n      ? ElementOf<N['children'][number]> | N | N['children'][number]\n      : N extends TElement\n        ? ElementOf<N> | N\n        : never;\n\n/** A utility type to get the child node types from a root node type. */\nexport type ChildOf<\n  N extends TNode,\n  I extends number = number,\n> = N extends Editor\n  ? N['children'][I]\n  : N extends TElement\n    ? N['children'][I]\n    : never;\n\n/** A utility type to get all the descendant node types from a root node type. */\nexport type DescendantIn<V extends Value> = DescendantOf<V[number]>;\n\nexport type DescendantOf<N extends TNode> = N extends Editor\n  ? ElementOf<N> | TextOf<N>\n  : N extends TElement\n    ? ElementOf<N['children'][number]> | TextOf<N>\n    : never;\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\nexport type Node = TNode;\n\nexport interface NodeAncestorsOptions {\n  reverse?: boolean;\n}\n\nexport interface NodeChildrenOptions {\n  /** Get children starting from this index (inclusive) */\n  from?: number;\n  reverse?: boolean;\n  /** Get children up to this index (exclusive) */\n  to?: number;\n}\n\nexport interface NodeDescendantsOptions<N extends TNode> {\n  from?: Path;\n  reverse?: boolean;\n  to?: Path;\n  pass?: (entry: NodeEntry<DescendantOf<N>>) => boolean;\n}\n\nexport interface NodeElementsOptions<N extends TNode> {\n  from?: Path;\n  reverse?: boolean;\n  to?: Path;\n  pass?: (entry: NodeEntry<ElementOf<N>>) => boolean;\n}\n\n/** A utility type to get all possible node types from a Value type */\nexport type NodeIn<V extends Value> = NodeOf<Editor | V[number]>;\n\nexport interface NodeLevelsOptions {\n  reverse?: boolean;\n}\n\nexport interface NodeNodesOptions<N extends TNode> {\n  from?: Path;\n  reverse?: boolean;\n  to?: Path;\n  pass?: (entry: NodeEntry<NodeOf<N>>) => boolean;\n}\n\n/** A utility type to get all the node types from a root node type. */\nexport type NodeOf<N extends TNode> = ElementOf<N> | N | TextOf<N>;\n\nexport interface NodeTextsOptions<N extends TNode> {\n  from?: Path;\n  reverse?: boolean;\n  to?: Path;\n  pass?: (entry: NodeEntry<TextOf<N>>) => boolean;\n}\n\n/** A helper type for narrowing matched nodes with a predicate. */\nexport type TNodeMatch<N extends TNode = TNode> =\n  | ((node: N, path: Path) => boolean)\n  | ((node: N, path: Path) => node is N);\n","import { isEditor } from 'slate';\n\nimport { NodeApi } from '../../interfaces';\n\nexport const NodeExtension = {\n  *children(root, path, options = {}) {\n    const { from, reverse = false, to } = options;\n    const ancestor = NodeApi.ancestor(root, path);\n\n    if (!ancestor) return;\n\n    const { children } = ancestor;\n    let index = reverse ? children.length - 1 : 0;\n    const endIndex = to ?? (reverse ? 0 : children.length);\n\n    if (from !== undefined) {\n      index = from;\n    }\n\n    while (reverse ? index >= endIndex : index < endIndex) {\n      const child = NodeApi.child(ancestor!, index);\n      const childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n  firstChild(root, path) {\n    const children = NodeApi.children(root, path);\n    const firstChild = children.next().value;\n\n    return firstChild as any;\n  },\n  firstText(root, options) {\n    const texts = NodeApi.texts(root, options);\n    const firstText = texts.next().value;\n\n    return firstText as any;\n  },\n  isEditor: (value: any) => isEditor(value),\n  isLastChild(root, path) {\n    if (path.length === 0) return false;\n\n    const parent = NodeApi.parent(root, path);\n\n    if (!parent) return false;\n\n    const index = path.at(-1);\n\n    return index === parent.children.length - 1;\n  },\n  lastChild(root, path) {\n    const children = NodeApi.children(root, path, { reverse: true });\n    const lastChild = children.next().value;\n\n    return lastChild as any;\n  },\n} as Pick<\n  typeof NodeApi,\n  'children' | 'firstChild' | 'firstText' | 'isLastChild' | 'lastChild'\n>;\n","import type {\n  Simplify,\n  UnionToIntersection,\n  UnknownObject,\n} from '@udecode/utils';\n\nimport {\n  type DecoratedRange as SlateDecoratedRange,\n  Text as SlateText,\n} from 'slate';\n\nimport type { Editor, Value } from './editor/editor-type';\nimport type { TElement } from './element';\nimport type { NodeProps, TNode } from './node';\n\nexport type LeafPosition = {\n  end: number;\n  start: number;\n  isFirst?: true;\n  isLast?: true;\n};\n\n/**\n * `TText` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\nexport type TText = { text: string } & UnknownObject;\n\n/** Text retrieval and check methods. */\nexport const TextApi: {\n  /** Get the leaves for a text node given decorations. */\n  decorations: <N extends TText>(\n    node: TText,\n    decorations: DecoratedRange[]\n  ) => { leaf: N; position: LeafPosition }[];\n  /** Check if two text nodes are equal. */\n  equals: (text: TText, another: TText, options?: TextEqualsOptions) => boolean;\n  /** Check if a value implements the `Text` interface. */\n  isText: <N extends TText>(value: any) => value is N;\n  /** Check if a value is a list of `Text` objects. */\n  isTextList: <N extends TText>(value: any) => value is N[];\n  /** Check if some props are a partial of Text. */\n  isTextProps: <N extends TText>(props: any) => props is Partial<N>;\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n  matches: <N extends TText>(text: N, props: Partial<N>) => boolean;\n} = SlateText as any;\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\nexport type DecoratedRange = SlateDecoratedRange;\n\n/** A utility type to get all the mark types from a root node type. */\nexport type MarkKeysOf<N extends TNode> =\n  {} extends MarksOf<N> ? unknown : keyof MarksOf<N>;\n\nexport type MarksIn<V extends Value> = MarksOf<V[number]>;\n\nexport type MarksOf<N extends TNode> = Simplify<\n  UnionToIntersection<NodeProps<TextOf<N>>>\n>;\n\nexport type Text = TText;\n\nexport interface TextEqualsOptions {\n  /**\n   * If true, the text is not compared. This is used to check whether sibling\n   * text nodes can be merged.\n   */\n  loose?: boolean;\n}\n\n/** A utility type to get all the text node types from a root node type. */\nexport type TextIn<V extends Value> = TextOf<V[number]>;\n\nexport type TextOf<N extends TNode> = Editor extends N\n  ? TText\n  : TElement extends N\n    ? TText\n    : N extends Editor\n      ? TextOf<N['children'][number]>\n      : N extends TElement\n        ? Extract<N['children'][number], TText> | TextOf<N['children'][number]>\n        : N extends TText\n          ? N\n          : never;\n","import { Operation as SlateOperation } from 'slate';\n\nimport type { Descendant, NodeProps } from './node';\nimport type { Path } from './path';\nimport type { TRange } from './range';\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\nexport type Operation<N extends Descendant = Descendant> =\n  | NodeOperation<N>\n  | SelectionOperation\n  | TextOperation;\n\n/** Operation manipulation and check methods. */\nexport const OperationApi: {\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n  inverse: (op: Operation) => Operation;\n  /** Check if a value is a `NodeOperation` object. */\n  isNodeOperation: <N extends Descendant>(\n    value: any\n  ) => value is NodeOperation<N>;\n  /** Check if a value is an `Operation` object. */\n  isOperation: <N extends Descendant>(value: any) => value is Operation<N>;\n  /** Check if a value is a list of `Operation` objects. */\n  isOperationList: (value: any) => value is Operation[];\n  /** Check if a value is a `SelectionOperation` object. */\n  isSelectionOperation: (value: any) => value is SelectionOperation;\n  /** Check if a value is a `TextOperation` object. */\n  isTextOperation: (value: any) => value is TextOperation;\n} = SlateOperation as any;\n\nexport type InsertNodeOperation<N extends Descendant = Descendant> = {\n  [key: string]: unknown;\n  node: N;\n  path: Path;\n  type: 'insert_node';\n};\n\nexport type InsertTextOperation = {\n  [key: string]: unknown;\n  offset: number;\n  path: Path;\n  text: string;\n  type: 'insert_text';\n};\n\nexport type MergeNodeOperation<N extends Descendant = Descendant> = {\n  [key: string]: unknown;\n  path: Path;\n  position: number;\n  properties: Partial<NodeProps<N>>;\n  type: 'merge_node';\n};\n\nexport type MoveNodeOperation = {\n  [key: string]: unknown;\n  newPath: Path;\n  path: Path;\n  type: 'move_node';\n};\n\nexport type NodeOperation<N extends Descendant = Descendant> =\n  | InsertNodeOperation<N>\n  | MergeNodeOperation<N>\n  | MoveNodeOperation\n  | RemoveNodeOperation<N>\n  | SetNodeOperation<N>\n  | SplitNodeOperation<N>;\n\nexport type RemoveNodeOperation<N extends Descendant = Descendant> = {\n  [key: string]: unknown;\n  node: N;\n  path: Path;\n  type: 'remove_node';\n};\n\nexport type RemoveTextOperation = {\n  [key: string]: unknown;\n  offset: number;\n  path: Path;\n  text: string;\n  type: 'remove_text';\n};\n\nexport type SelectionOperation = SetSelectionOperation;\n\nexport type SetNodeOperation<\n  N1 extends Descendant = Descendant,\n  N2 extends Descendant = Descendant,\n> = {\n  [key: string]: unknown;\n  newProperties: Partial<NodeProps<N1>>;\n  path: Path;\n  properties: Partial<NodeProps<N2>>;\n  type: 'set_node';\n};\n\nexport type SetSelectionOperation =\n  | {\n      [key: string]: unknown;\n      newProperties: null;\n      properties: TRange;\n      type: 'set_selection';\n    }\n  | {\n      [key: string]: unknown;\n      newProperties: Partial<TRange>;\n      properties: Partial<TRange>;\n      type: 'set_selection';\n    }\n  | {\n      [key: string]: unknown;\n      newProperties: TRange;\n      properties: null;\n      type: 'set_selection';\n    };\n\nexport type SplitNodeOperation<N extends Descendant = Descendant> = {\n  [key: string]: unknown;\n  path: Path;\n  position: number;\n  properties: Partial<NodeProps<N>>;\n  type: 'split_node';\n};\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation;\n","import { Point as SlatePoint } from 'slate';\n\nimport type { At, TextDirection } from '../types';\nimport type { Operation } from './operation';\n\nimport { type Path, PathApi } from './path';\nimport { RangeApi } from './range';\n\nexport type Point = {\n  /** The index of the character in the text node. */\n  offset: number;\n  /** The path to the text node. */\n  path: Path;\n};\n\n/** Point retrieval, check and transform methods. */\nexport const PointApi: {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n  compare: (point: Point, another: Point) => -1 | 0 | 1;\n  /** Check if a point is exactly equal to another. */\n  equals: (point: Point, another: Point) => boolean;\n  /**\n   * Get the point from a location. If the location is a range, get the anchor\n   * point (if `focus` is true, get the focus point). If the location is a path,\n   * get the point at this path with offset 0.\n   */\n  get: (\n    at?: At | null,\n    {\n      focus,\n    }?: {\n      focus?: boolean;\n    }\n  ) => Point | undefined;\n  /** Check if a point is after another. */\n  isAfter: (point: Point, another: Point) => boolean;\n  /** Check if a point is before another. */\n  isBefore: (point: Point, another: Point) => boolean;\n  /** Check if a value implements the `Point` interface. */\n  isPoint: (value: any) => value is Point;\n  /** Transform a point by an operation. */\n  transform: (\n    point: Point,\n    op: Operation,\n    options?: PointTransformOptions\n  ) => Point | null;\n} = {\n  ...(SlatePoint as any),\n  get: (at, { focus } = {}) => {\n    let point: Point | undefined;\n\n    if (RangeApi.isRange(at)) point = focus ? at.focus : at.anchor;\n    if (PointApi.isPoint(at)) point = at;\n    if (PathApi.isPath(at)) point = { offset: 0, path: at };\n\n    return point;\n  },\n};\n\nexport type PointEntry = [Point, 'anchor' | 'focus'];\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport interface PointTransformOptions {\n  affinity?: TextDirection | null;\n}\n","import { Range as SlateRange } from 'slate';\n\nimport type { RangeDirection } from '../types';\nimport type { Operation } from './operation';\nimport type { Path } from './path';\nimport type { Point, PointEntry } from './point';\n\n/**\n * `TRange` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\nexport type TRange = {\n  /** The start point of the range. */\n  anchor: Point;\n  /** The end point of the range. */\n  focus: Point;\n};\n\nexport const RangeApi: {\n  /**\n   * Check if a range fully contains another range, meaning that both the start\n   * and end points of the target range are included in the range.\n   */\n  contains: (range: TRange, target: TRange) => boolean;\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n  edges: (range: TRange, options?: RangeEdgesOptions) => [Point, Point];\n  /** Get the end point of a range. */\n  end: (range: TRange) => Point;\n  /** Check if a range is exactly equal to another. */\n  equals: (range: TRange, another: TRange) => boolean;\n  /** Check if a range includes a path, a point or part of another range. */\n  includes: (range: TRange, target: Path | Point | TRange) => boolean;\n  /** Get the intersection of a range with another. */\n  intersection: (range: TRange, another: TRange) => TRange | null;\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n  isBackward: (range: TRange) => boolean;\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n  isCollapsed: (range?: TRange | null) => boolean;\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[RangeApi.isCollapsed]] and is provided for\n   * legibility.\n   */\n  isExpanded: (range?: TRange | null) => boolean;\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[RangeApi.isBackward]] and is provided for\n   * legibility.\n   */\n  isForward: (range: TRange) => boolean;\n  /** Check if a value implements the [[TRange]] interface. */\n  isRange: (value: any) => value is TRange;\n  /** Iterate through all of the point entries in a range. */\n  points: (range: TRange) => Generator<PointEntry, void, undefined>;\n  /** Get the start point of a range. */\n  start: (range: TRange) => Point;\n  /** Check if a range includes another range. */\n  surrounds: (range: TRange, target: TRange) => boolean;\n  /** Transform a range by an operation. */\n  transform: (\n    range: TRange,\n    op: Operation,\n    options?: RangeTransformOptions\n  ) => TRange | null;\n} = {\n  ...SlateRange,\n  contains: (range: TRange, target: TRange) => {\n    const [targetStart, targetEnd] = RangeApi.edges(target);\n\n    return (\n      RangeApi.includes(range, targetStart) &&\n      RangeApi.includes(range, targetEnd)\n    );\n  },\n  isCollapsed: (range?: TRange | null) =>\n    !!range && SlateRange.isCollapsed(range),\n  isExpanded: (range?: TRange | null) =>\n    !!range && SlateRange.isExpanded(range),\n} as any;\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\nexport type Range = TRange;\n\nexport interface RangeEdgesOptions {\n  reverse?: boolean;\n}\n\nexport interface RangeTransformOptions {\n  affinity?: RangeDirection | null;\n}\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const blur = (editor: Editor) => DOMEditor.blur(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const deselectDOM = (editor: Editor) =>\n  DOMEditor.deselect(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const findDocumentOrShadowRoot = (editor: Editor) => {\n  try {\n    return DOMEditor.findDocumentOrShadowRoot(editor as any);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const findEventRange = (editor: Editor, event: any) => {\n  try {\n    return DOMEditor.findEventRange(editor as any, event);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { TNode } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor';\n\nexport const findKey = (editor: Editor, node: TNode) => {\n  try {\n    return DOMEditor.findKey(editor as any, node);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Path } from '../../interfaces';\nimport type { Editor, EditorFindPathOptions } from '../../interfaces/editor';\nimport type { TNode } from '../../interfaces/node';\n\nexport const findPath = (\n  editor: Editor,\n  node: TNode,\n  options?: EditorFindPathOptions\n): Path | undefined => {\n  const findNodePath = () => {\n    const nodeEntry = editor.api.node({\n      ...options,\n      at: [],\n      match: (n) => n === node,\n    });\n\n    return nodeEntry?.[1];\n  };\n\n  if (options) {\n    return findNodePath();\n  }\n\n  try {\n    return DOMEditor.findPath(editor as any, node);\n  } catch {\n    return findNodePath();\n  }\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor, FocusOptions } from '../../interfaces/editor';\nimport type { At } from '../../types';\n\nexport const focus = (\n  editor: Editor,\n  { at, edge, retries = 5 }: FocusOptions = {}\n) => {\n  const reselect = (at: At) => {\n    editor.tf.withoutNormalizing(() => {\n      editor.tf.deselect();\n      editor.tf.select(at);\n    });\n  };\n\n  if (edge) {\n    const target: At | null =\n      edge === 'startEditor' || edge === 'endEditor'\n        ? []\n        : (at ?? editor.selection);\n\n    if (target) {\n      reselect(\n        edge === 'start' ? editor.api.start(target)! : editor.api.end(target)!\n      );\n    }\n  } else if (at) {\n    reselect(at);\n  }\n\n  try {\n    DOMEditor.focus(editor as any, { retries });\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const getWindow = (editor: Editor) => {\n  try {\n    return DOMEditor.getWindow(editor as any);\n  } catch {}\n};\n","import type { DOMNode } from 'slate-dom';\n\nimport { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasDOMNode = (\n  editor: Editor,\n  target: DOMNode,\n  options?: Parameters<typeof DOMEditor.hasDOMNode>[2]\n) => {\n  try {\n    return DOMEditor.hasDOMNode(editor as any, target, options);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasEditableTarget = (\n  editor: Editor,\n  target: EventTarget | null\n): target is Node => {\n  try {\n    return DOMEditor.hasEditableTarget(editor as any, target);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { TRange } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasRange = (editor: Editor, range: TRange): boolean => {\n  try {\n    return DOMEditor.hasRange(editor as any, range);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasSelectableTarget = (\n  editor: Editor,\n  target: EventTarget | null\n) => {\n  try {\n    return DOMEditor.hasSelectableTarget(editor as any, target);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const hasTarget = (\n  editor: Editor,\n  target: EventTarget | null\n): target is Node => {\n  try {\n    return DOMEditor.hasTarget(editor as any, target);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const isComposing = (editor: Editor) =>\n  DOMEditor.isComposing(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const isFocused = (editor: Editor) => DOMEditor.isFocused(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const isReadOnly = (editor: Editor) =>\n  DOMEditor.isReadOnly(editor as any);\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const isTargetInsideNonReadonlyVoid = (\n  editor: Editor,\n  target: EventTarget | null\n) => {\n  try {\n    return DOMEditor.isTargetInsideNonReadonlyVoid(editor as any, target);\n  } catch {}\n\n  return false;\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { TNode } from '../../interfaces/node';\n\nexport const toDOMNode = (editor: Editor, node: TNode) => {\n  try {\n    return DOMEditor.toDOMNode(editor as any, node);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { Point } from '../../interfaces/point';\n\nexport const toDOMPoint = (editor: Editor, point: Point) => {\n  try {\n    return DOMEditor.toDOMPoint(editor as any, point);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { TRange } from '../../interfaces/range';\n\nexport const toDOMRange = (editor: Editor, range: TRange) => {\n  try {\n    return DOMEditor.toDOMRange(editor as any, range);\n  } catch {}\n};\n","import type { DOMNode } from 'slate-dom';\n\nimport { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { TNode } from '../../interfaces/node';\n\nexport const toSlateNode = (editor: Editor, domNode: DOMNode) => {\n  try {\n    return DOMEditor.toSlateNode(editor as any, domNode) as TNode;\n  } catch {}\n};\n","import type { DOMPoint } from 'slate-dom';\n\nimport { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const toSlatePoint = (\n  editor: Editor,\n  domPoint: DOMPoint,\n  options: Omit<Parameters<typeof DOMEditor.toSlatePoint>[2], 'suppressThrow'>\n) => {\n  try {\n    return DOMEditor.toSlatePoint(editor as any, domPoint, options as any);\n  } catch {}\n};\n","import { DOMEditor } from 'slate-dom';\n\nimport type { Editor } from '../../interfaces/editor';\n\nexport const toSlateRange = (\n  editor: Editor,\n  domRange: Parameters<typeof DOMEditor.toSlateRange>[1],\n  options: Omit<Parameters<typeof DOMEditor.toSlateRange>[2], 'supressThrow'>\n) => {\n  try {\n    return DOMEditor.toSlateRange(editor as any, domRange, options);\n  } catch {}\n};\n","import type {\n  Editor,\n  EditorAboveOptions,\n  ElementOf,\n  NodeEntry,\n  ValueOf,\n} from '../../interfaces/index';\n\nexport const edgeBlocks = <\n  N1 extends ElementOf<E>,\n  N2 extends ElementOf<E> = N1,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  { at: _at, ...options }: EditorAboveOptions<ValueOf<E>> = {}\n): [NodeEntry<N1>, NodeEntry<N2>] | null => {\n  const at = _at ?? editor.selection;\n\n  if (!at) return null;\n\n  const [start, end] = editor.api.edges(at ?? editor.selection)!;\n\n  const startBlock = editor.api.block<N1>({\n    at: start,\n    ...options,\n  } as any);\n\n  if (!startBlock) return null;\n\n  const endBlock = editor.api.block<N2>({\n    at: end,\n    ...options,\n  } as any);\n\n  if (!endBlock) return null;\n\n  return [startBlock, endBlock];\n};\n","import type {\n  Editor,\n  EditorBlockOptions,\n  ElementOf,\n  ValueOf,\n} from '../../interfaces/index';\n\nexport const block = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  { above, highest, ...options }: EditorBlockOptions<ValueOf<E>> = {}\n) => {\n  if (highest) {\n    const target = options.at ?? editor.selection;\n\n    if (!target) return;\n\n    const index = editor.api.path(target as any)?.[0];\n\n    if (index === undefined) return;\n\n    return editor.api.node<N>([index]);\n  }\n  if (above) {\n    return editor.api.above<N>({\n      ...(options as any),\n      block: true,\n    });\n  }\n\n  return editor.api.node<N>({\n    ...options,\n    block: true,\n    mode: 'lowest',\n  });\n};\n","import type {\n  Editor,\n  EditorNodesOptions,\n  ElementOf,\n  ValueOf,\n} from '../../interfaces/index';\n\nexport const blocks = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorNodesOptions<ValueOf<E>>\n) => {\n  return [\n    ...editor.api.nodes<N>({\n      ...options,\n      block: true,\n    }),\n  ];\n};\n","import type { Editor, LegacyEditorMethods } from '../interfaces';\n\nconst LEGACY_TRANSFORMS = new Set([\n  'addMark',\n  'apply',\n  'blur',\n  'collapse',\n  'delete',\n  'deleteBackward',\n  'deleteForward',\n  'deleteFragment',\n  'deselect',\n  'deselectDOM',\n  'focus',\n  'insertBreak',\n  'insertData',\n  'insertFragment',\n  'insertFragmentData',\n  'insertNode',\n  'insertNodes',\n  'insertSoftBreak',\n  'insertText',\n  'insertTextData',\n  'liftNodes',\n  'mergeNodes',\n  'move',\n  'moveNodes',\n  'normalize',\n  'normalizeNode',\n  'redo',\n  'removeMark',\n  'removeNodes',\n  'select',\n  'setFragmentData',\n  'setNodes',\n  'setPoint',\n  'setSelection',\n  'setSplittingOnce',\n  'splitNodes',\n  'undo',\n  'unsetNodes',\n  'unwrapNodes',\n  'withMerging',\n  'withNewBatch',\n  'withoutMerging',\n  'withoutNormalizing',\n  'withoutSaving',\n  'wrapNodes',\n  'writeHistory',\n]);\n\nconst LEGACY_API = new Set([\n  'above',\n  'after',\n  'before',\n  'edges',\n  'elementReadOnly',\n  'end',\n  'findDocumentOrShadowRoot',\n  'findEventRange',\n  'findKey',\n  'findPath',\n  'first',\n  'fragment',\n  'getDirtyPaths',\n  'getFragment',\n  'getMarks',\n  'getWindow',\n  'hasBlocks',\n  'hasDOMNode',\n  'hasEditableTarget',\n  'hasInlines',\n  'hasPath',\n  'hasRange',\n  'hasSelectableTarget',\n  'hasTarget',\n  'hasTexts',\n  'highestBlock',\n  'isBlock',\n  'isComposing',\n  'isEdge',\n  'isElementReadOnly',\n  'isEmpty',\n  'isEnd',\n  'isFocused',\n  'isInline',\n  'isMerging',\n  'isNormalizing',\n  'isReadOnly',\n  'isSaving',\n  'isSelectable',\n  'isSplittingOnce',\n  'isStart',\n  'isTargetInsideNonReadonlyVoid',\n  'isVoid',\n  'last',\n  'leaf',\n  'levels',\n  'markableVoid',\n  // 'marks',\n  'next',\n  'node',\n  'nodes',\n  'normalize',\n  'onChange',\n  'operations',\n  'parent',\n  'path',\n  'pathRef',\n  'pathRefs',\n  'point',\n  'pointRef',\n  'pointRefs',\n  'positions',\n  'previous',\n  'range',\n  'rangeRef',\n  'rangeRefs',\n  'selection',\n  'setNormalizing',\n  'shouldMergeNodesRemovePrevNode',\n  'shouldNormalize',\n  'start',\n  'string',\n  'toDOMNode',\n  'toDOMPoint',\n  'toDOMRange',\n  'toSlateNode',\n  'toSlatePoint',\n  'toSlateRange',\n  'unhangRange',\n  'void',\n]);\n\nexport const assignLegacyTransforms = (editor: Editor, transforms: any) => {\n  if (!transforms) return;\n\n  const e = editor as Editor & LegacyEditorMethods;\n\n  const legacyTransforms = Object.entries(transforms).reduce(\n    (acc, [key, value]) => {\n      if (LEGACY_TRANSFORMS.has(key)) {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n\n  Object.assign(e, legacyTransforms);\n};\n\nexport const assignLegacyApi = (editor: Editor, api: any) => {\n  if (!api) return;\n\n  const e = editor as Editor & LegacyEditorMethods;\n\n  const legacyApi = Object.entries(api).reduce(\n    (acc, [key, value]) => {\n      if (LEGACY_API.has(key)) {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n\n  Object.assign(e, legacyApi);\n\n  if (api.marks) {\n    e.getMarks = api.marks;\n  }\n};\n\n/**\n * Assigns editor's legacy methods to editor.api and editor.tf.\n *\n * NOTE: can't use yet because of recursion issues\n */\nexport const syncLegacyMethods = (editor: Editor) => {\n  const e = editor as Editor & LegacyEditorMethods;\n\n  // Assign to editor.api\n  LEGACY_API.forEach((key) => {\n    if (e[key]) {\n      if (key === 'getMarks') {\n        // Special case for marks\n        (e.api as any).marks = e.getMarks;\n      } else {\n        (e.api as any)[key] = e[key];\n      }\n    }\n  });\n\n  // Assign to editor.tf\n  LEGACY_TRANSFORMS.forEach((key) => {\n    if (e[key]) {\n      (e.tf as any)[key] = e[key];\n    }\n  });\n};\n","import { Editor as EditorInterface } from 'slate';\n\nimport type { Editor } from '../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../interfaces/node-entry';\n\nimport {\n  type LegacyEditorMethods,\n  type Path,\n  type TLocation,\n  type TRange,\n  PathApi,\n  PointApi,\n  RangeApi,\n} from '../interfaces/index';\nimport { createPathRef } from '../internal/editor/createPathRef';\nimport { createPointRef } from '../internal/editor/createPointRef';\nimport { getEndPoint } from '../internal/editor/getEndPoint';\nimport { getLeafNode } from '../internal/editor/getLeafNode';\nimport { getPointAfter } from '../internal/editor/getPointAfter';\nimport { getPointBefore } from '../internal/editor/getPointBefore';\nimport { getStartPoint } from '../internal/editor/getStartPoint';\nimport { getVoidNode } from '../internal/editor/getVoidNode';\nimport { isBlock } from '../internal/editor/isBlock';\nimport { nodes } from '../internal/editor/nodes';\nimport { withoutNormalizing } from '../internal/editor/withoutNormalizing';\nimport { select } from '../internal/transforms/select';\n\nexport const deleteMerge = (\n  editor: Editor,\n  options: {\n    at?: TLocation;\n    distance?: number;\n    hanging?: boolean;\n    reverse?: boolean;\n    test?: any;\n    unit?: 'block' | 'character' | 'line' | 'word';\n    voids?: boolean;\n  } = {}\n): void => {\n  const e = editor as Editor & LegacyEditorMethods;\n\n  withoutNormalizing(e as any, () => {\n    const {\n      distance = 1,\n      reverse = false,\n      unit = 'character',\n      voids = false,\n    } = options;\n    let { at = e.selection!, hanging = false } = options;\n\n    if (!at) {\n      return;\n    }\n    if (RangeApi.isRange(at) && RangeApi.isCollapsed(at)) {\n      at = at.anchor;\n    }\n    if (PointApi.isPoint(at)) {\n      const furthestVoid = getVoidNode(e as any, { at, mode: 'highest' });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = { distance, unit };\n        const target = reverse\n          ? getPointBefore(e as any, at, opts) || getStartPoint(e as any, [])!\n          : getPointAfter(e as any, at, opts) || getEndPoint(e as any, [])!;\n        at = { anchor: at, focus: target };\n        hanging = true;\n      }\n    }\n    if (PathApi.isPath(at)) {\n      e.tf.removeNodes({ at, voids });\n\n      return;\n    }\n    if (RangeApi.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      at = EditorInterface.unhangRange(e as any, at, { voids });\n    }\n\n    let [start, end] = RangeApi.edges(at as TRange);\n    const startBlock = e.api.above({\n      at: start,\n      voids,\n      match: (n) => isBlock(e as any, n),\n    });\n    const endBlock = e.api.above({\n      at: end,\n      voids,\n      match: (n) => isBlock(e as any, n),\n    });\n    const isAcrossBlocks =\n      startBlock && endBlock && !PathApi.equals(startBlock[1], endBlock[1]);\n    const isSingleText = PathApi.equals(start.path, end.path);\n    const startVoid = voids\n      ? null\n      : getVoidNode(e as any, { at: start, mode: 'highest' });\n    const endVoid = voids\n      ? null\n      : getVoidNode(e as any, { at: end, mode: 'highest' });\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startVoid) {\n      const before = getPointBefore(e as any, start);\n\n      if (\n        before &&\n        startBlock &&\n        PathApi.isAncestor(startBlock[1], before.path)\n      ) {\n        start = before;\n      }\n    }\n    if (endVoid) {\n      const after = getPointAfter(e as any, end);\n\n      if (after && endBlock && PathApi.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: NodeEntry[] = [];\n    let lastPath: Path | undefined;\n\n    const _nodes = nodes(e as any, { at, voids });\n\n    for (const entry of _nodes) {\n      const [node, path] = entry;\n\n      if (lastPath && PathApi.compare(path, lastPath) === 0) {\n        continue;\n      }\n      if (\n        (!voids && e.api.isVoid(node as any)) ||\n        (!PathApi.isCommon(path, start.path) &&\n          !PathApi.isCommon(path, end.path))\n      ) {\n        matches.push(entry as any);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) => createPathRef(e as any, p));\n    const startRef = createPointRef(e as any, start);\n    const endRef = createPointRef(e as any, end);\n\n    if (!isSingleText && !startVoid) {\n      const point = startRef.current!;\n      const [node] = getLeafNode(e as any, point)!;\n      const { path } = point;\n      const { offset } = start;\n      const text = node.text.slice(offset);\n      e.apply({ offset, path, text, type: 'remove_text' });\n    }\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!;\n      e.tf.removeNodes({ at: path, voids });\n    }\n\n    if (!endVoid) {\n      const point = endRef.current!;\n      const [node] = getLeafNode(e as any, point)!;\n      const { path } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      e.apply({ offset, path, text, type: 'remove_text' });\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      // DIFF: allow custom mergeNodes\n      e.tf.mergeNodes({\n        at: endRef.current,\n        hanging: true,\n        voids,\n      });\n    }\n\n    const point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      select(e as any, point);\n    }\n  });\n};\n","import type { EditorPathRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { pathRef } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { Path } from '../../interfaces/path';\n\nexport const createPathRef = (\n  editor: Editor,\n  at: Path,\n  options?: EditorPathRefOptions\n) => pathRef(editor as any, at, options as any);\n","import type { EditorPointRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { pointRef } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { Point } from '../../interfaces/point';\n\nexport const createPointRef = (\n  editor: Editor,\n  point: Point,\n  options?: EditorPointRefOptions\n) => pointRef(editor as any, point, options as any);\n","import { end } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorEndOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const getEndPoint = (\n  editor: Editor,\n  at: At,\n  options: EditorEndOptions = {}\n) => {\n  try {\n    if (options.previous) {\n      const prevEntry = editor.api.previous({ at: getAt(editor, at)! });\n\n      if (!prevEntry) return;\n\n      return end(editor as any, prevEntry[1]);\n    }\n\n    return end(editor as any, getAt(editor, at)!);\n  } catch {}\n};\n","import isPlainObject from 'lodash/isPlainObject.js';\n\nimport { type Editor, type TNode, NodeApi } from '../interfaces';\n\nexport const getAt = <T>(\n  editor: Editor,\n  at?: T | TNode | null\n): T | undefined => {\n  if (at && isPlainObject(at) && NodeApi.isNode(at)) {\n    return editor.api.findPath(at) as any;\n  }\n\n  return (at as T) ?? undefined;\n};\n","import type { EditorLeafOptions } from 'slate/dist/interfaces/editor';\n\nimport { leaf } from 'slate';\n\nimport type { TextOf } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getLeafNode = <N extends TextOf<E>, E extends Editor>(\n  editor: E,\n  at: At,\n  options?: EditorLeafOptions\n): NodeEntry<N> | undefined => {\n  try {\n    return leaf(editor as any, getAt(editor, at)!, options) as any;\n  } catch {}\n};\n","import { after } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorAfterOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getPointAfter = (\n  editor: Editor,\n  at: At,\n  options?: EditorAfterOptions\n) => {\n  try {\n    return after(editor as any, getAt(editor, at)!, options as any);\n  } catch {}\n};\n","import castArray from 'lodash/castArray.js';\nimport map from 'lodash/map.js';\nimport { before as beforeBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorBeforeOptions, Point } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getPointBefore = (\n  editor: Editor,\n  at: At,\n  options?: EditorBeforeOptions\n): Point | undefined => {\n  if (!options || (!options.match && !options.matchString)) {\n    try {\n      return beforeBase(editor as any, getAt(editor, at)!, options as any);\n    } catch {}\n\n    return;\n  }\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  const matchStrings: string[] = options.matchString\n    ? castArray(options.matchString)\n    : [''];\n\n  const matchByRegex = options.matchByRegex ?? false;\n\n  let point: any;\n\n  matchStrings.some((matchString) => {\n    let beforeAt = at;\n    let previousBeforePoint = editor.api.point(at, { edge: 'end' })!;\n\n    const stackLength = matchString.length + 1;\n    const stack: any[] = Array.from({ length: stackLength });\n\n    let count = 0;\n\n    while (true) {\n      const beforePoint = beforeBase(\n        editor as any,\n        getAt(editor, beforeAt)!,\n        options as any\n      );\n\n      // not found\n      if (!beforePoint) {\n        if (options.matchBlockStart) {\n          point = previousBeforePoint;\n        }\n\n        return;\n      }\n      // stop looking outside of current block\n      if (\n        editor.api.isAt({\n          at: {\n            anchor: beforePoint,\n            focus: previousBeforePoint,\n          },\n          blocks: true,\n        })\n      ) {\n        if (options.matchBlockStart) {\n          point = previousBeforePoint;\n        }\n\n        return;\n      }\n\n      const beforeString = editor.api.string({\n        anchor: beforePoint,\n        focus: previousBeforePoint,\n      });\n\n      let beforeStringToMatch = beforeString;\n\n      if (unitOffset && stackLength) {\n        stack.unshift({\n          point: beforePoint,\n          text: beforeString,\n        });\n        stack.pop();\n\n        beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n      }\n\n      const isMatched = matchByRegex\n        ? !!matchString.match(beforeStringToMatch)\n        : beforeStringToMatch === matchString;\n\n      if (\n        isMatched ||\n        options.match?.({ at, beforePoint, beforeString: beforeStringToMatch })\n      ) {\n        if (options.afterMatch) {\n          if (stackLength && unitOffset) {\n            point = stack.at(-1)?.point;\n\n            return !!point;\n          }\n\n          point = previousBeforePoint;\n\n          return true;\n        }\n\n        point = beforePoint;\n\n        return true;\n      }\n\n      previousBeforePoint = beforePoint;\n      beforeAt = beforePoint;\n\n      count += 1;\n\n      if (!options.skipInvalid && (!matchString || count >= matchString.length))\n        return;\n    }\n  });\n\n  return point;\n};\n","import { start } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorStartOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getStartPoint = (\n  editor: Editor,\n  at: At,\n  options: EditorStartOptions = {}\n) => {\n  try {\n    if (options.next) {\n      const nextEntry = editor.api.next({ at: getAt(editor, at)! });\n\n      if (!nextEntry) return;\n\n      return start(editor as any, nextEntry[1]);\n    }\n\n    return start(editor as any, getAt(editor, at)!);\n  } catch {}\n};\n","import { getVoid } from 'slate';\n\nimport type { EditorVoidOptions, ElementOf } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport { getAt } from '../../utils';\n\nexport const getVoidNode = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorVoidOptions\n): NodeEntry<N> | undefined =>\n  getVoid(editor as any, {\n    ...options,\n    at: getAt(editor, options?.at),\n  }) as any;\n","import { isBlock as isBlockBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nimport { type TElement, ElementApi } from '../../interfaces/element';\n\nexport const isBlock = (editor: Editor, value: any): value is TElement =>\n  ElementApi.isElement(value) && isBlockBase(editor as any, value);\n","import type { Editor } from '../interfaces/editor/editor-type';\nimport type { NodeOf, TNode } from '../interfaces/node';\n\nimport { type Path, TextApi } from '../interfaces/index';\nimport { getAt } from './getAt';\n\nexport type Predicate<T extends TNode> = PredicateFn<T> | PredicateObj;\n\ntype PredicateFn<T extends TNode> = (obj: T, path: Path) => boolean;\n\ntype PredicateObj = Record<string, any[] | any>;\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Match the object with a predicate object or function. If predicate is:\n *\n * - Object: every predicate key/value should be in obj.\n * - Function: it should return true.\n */\nexport const match = <T extends TNode>(\n  obj: T,\n  path: Path,\n  predicate?: Predicate<T>\n): boolean => {\n  if (!predicate) return true;\n  if (typeof predicate === 'object') {\n    return Object.entries(predicate).every(([key, value]) => {\n      const values = castArray<any>(value);\n\n      return values.includes((obj as any)[key]);\n    });\n  }\n\n  return predicate(obj, path);\n};\n\nexport const getMatch = <E extends Editor>(\n  editor: E,\n  { id, block, empty, match: matchObjOrFn, text }: any = {}\n) => {\n  let hasMatch = false;\n  let matchFn: PredicateFn<NodeOf<E>> = () => true;\n\n  // If text option is true/false, match only text/non-text nodes\n  if (text !== undefined) {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n) => TextApi.isText(n) === text);\n  }\n  // If empty option is true/false, match only empty/non-empty nodes\n  if (empty !== undefined) {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n) => {\n      return TextApi.isText(n)\n        ? n.text.length > 0 === !empty\n        : editor.api.isEmpty(n) === empty;\n    });\n  }\n  if (block !== undefined) {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n) => editor.api.isBlock(n) === block);\n  }\n  if (id !== undefined) {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n) => {\n      return (id === true && !!n.id) || n.id === id;\n    });\n  }\n  // Handle object predicate matching first\n  if (typeof matchObjOrFn === 'object') {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, (n, p) => match(n, p, matchObjOrFn));\n  } else if (typeof matchObjOrFn === 'function') {\n    hasMatch = true;\n    matchFn = combineMatch(matchFn, matchObjOrFn);\n  }\n\n  return hasMatch ? matchFn : undefined;\n};\n\n/**\n * Extended query options for slate queries:\n *\n * - `match` can be an object predicate where one of the values should include the\n *   node value. Example: { type: ['1', '2'] } will match the nodes having one\n *   of these 2 types.\n */\nexport const getQueryOptions = (\n  editor: Editor,\n  { id, empty, match, text, ...options }: any = {}\n) => {\n  const { at, block } = options;\n\n  return {\n    ...options,\n    at: getAt(editor, at),\n    match: getMatch(editor, { id, block, empty, match, text }),\n  };\n};\n\nexport const combineMatch = <T extends TNode>(\n  match1: PredicateFn<T>,\n  match2?: PredicateFn<T>\n): PredicateFn<T> => {\n  return (node: T, path: Path) => {\n    return match1(node, path) && (!match2 || match2(node, path));\n  };\n};\n\n/** Combine two match predicates into one. */\nexport const combineMatchOptions = <E extends Editor>(\n  editor: E,\n  match1?: PredicateFn<NodeOf<E>>,\n  options?: any\n): PredicateFn<NodeOf<E>> => {\n  return (node: NodeOf<E>, path: Path) => {\n    const match2 = getMatch(editor, options);\n\n    return (!match1 || match1(node, path)) && (!match2 || match2(node, path));\n  };\n};\n","import type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport {\n  type DescendantOf,\n  type EditorNodesOptions,\n  ElementApi,\n  NodeApi,\n  PathApi,\n  SpanApi,\n  TextApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\nimport { getMatch, getQueryOptions } from '../../utils/match';\n\nexport function* nodes<N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>> = {}\n): Generator<NodeEntry<N>, void, undefined> {\n  options = getQueryOptions(editor, options);\n\n  // if (options?.at) {\n  //   editor.api.unhangRange(options.at as any, options);\n  // }\n\n  const {\n    ignoreNonSelectable = false,\n    mode = 'all',\n    reverse = false,\n    universal = false,\n    voids = false,\n  } = options;\n  const at = getAt(editor, options.at) ?? editor.selection;\n  let match = getMatch(editor, options);\n\n  if (!match) {\n    match = () => true;\n  }\n  if (!at) {\n    return;\n  }\n\n  let from;\n  let to;\n\n  if (SpanApi.isSpan(at)) {\n    from = at[0];\n    to = at[1];\n  } else {\n    const first = editor.api.path(at, { edge: 'start' });\n    const last = editor.api.path(at, { edge: 'end' });\n    from = reverse ? last : first;\n    to = reverse ? first : last;\n\n    // FORK: return early if no path is found\n    if (!first || !last) {\n      return;\n    }\n  }\n\n  const nodeEntries = NodeApi.nodes(editor, {\n    from,\n    reverse,\n    to,\n    pass: ([node]) => {\n      if (!ElementApi.isElement(node)) return false;\n      if (\n        !voids &&\n        (editor.api.isVoid(node) || editor.api.isElementReadOnly(node))\n      ) {\n        return true;\n      }\n      if (ignoreNonSelectable && !editor.api.isSelectable(node)) {\n        return true;\n      }\n\n      return false;\n    },\n  });\n\n  const matches: NodeEntry<N>[] = [];\n  let hit: NodeEntry<N> | undefined;\n\n  for (const [node, path] of nodeEntries) {\n    if (\n      ignoreNonSelectable &&\n      ElementApi.isElement(node) &&\n      !editor.api.isSelectable(node)\n    ) {\n      continue;\n    }\n\n    const isLower = hit && PathApi.compare(path, hit[1]) === 0;\n\n    // In highest mode any node lower than the last hit is not a match.\n    if (mode === 'highest' && isLower) {\n      continue;\n    }\n    if (!match(node, path)) {\n      // If we've arrived at a leaf text node that is not lower than the last\n      // hit, then we've found a branch that doesn't include a match, which\n      // means the match is not universal.\n      if (universal && !isLower && TextApi.isText(node)) {\n        return;\n      } else {\n        continue;\n      }\n    }\n    // If there's a match and it's lower than the last, update the hit.\n    if (mode === 'lowest' && isLower) {\n      hit = [node, path] as NodeEntry<N>;\n\n      continue;\n    }\n\n    // In lowest mode we emit the last hit, once it's guaranteed lowest.\n    const emit: NodeEntry<N> | undefined =\n      mode === 'lowest' ? hit : ([node, path] as NodeEntry<N>);\n\n    if (emit) {\n      if (universal) {\n        matches.push(emit);\n      } else {\n        yield emit;\n      }\n    }\n\n    hit = [node, path] as NodeEntry<N>;\n  }\n\n  // Since lowest is always emitting one behind, catch up at the end.\n  if (mode === 'lowest' && hit) {\n    if (universal) {\n      matches.push(hit);\n    } else {\n      yield hit;\n    }\n  }\n  // Universal defers to ensure that the match occurs in every branch, so we\n  // yield all of the matches after iterating.\n  if (universal) {\n    yield* matches;\n  }\n}\n","import { withoutNormalizing as withoutNormalizingBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const withoutNormalizing = (\n  editor: Editor,\n  fn: () => boolean | void\n) => {\n  let normalized = false;\n\n  withoutNormalizingBase(editor as any, () => {\n    normalized = !!fn();\n  });\n\n  return normalized;\n};\n","import { select as selectBase } from 'slate';\n\nimport type { At } from '../../types';\n\nimport { type Editor, type SelectOptions, PathApi } from '../../interfaces';\nimport { getAt } from '../../utils/getAt';\n\nexport const select = (\n  editor: Editor,\n  target?: At,\n  options: SelectOptions = {}\n) => {\n  const { edge, focus, next, previous } = options;\n\n  if (focus) {\n    editor.tf.focus();\n  }\n  // Handle sibling selection\n  if (next || previous) {\n    const at = getAt(editor, target) ?? editor.selection;\n\n    if (!at) return;\n\n    const path = editor.api.path(at);\n\n    if (!path) return;\n\n    const point = previous\n      ? editor.api.end(path, { previous: true })\n      : editor.api.start(path, { next: true });\n\n    if (!point) return;\n\n    selectBase(editor as any, point);\n\n    return;\n  }\n  // Handle edge selection\n  if (edge) {\n    const at = getAt(editor, target) ?? editor.selection;\n\n    if (!at) return;\n\n    const path = PathApi.isPath(at)\n      ? at\n      : editor.api.node({ at, block: true })?.[1];\n\n    if (!path) return;\n\n    const point =\n      edge === 'end' ? editor.api.end(path) : editor.api.start(path);\n\n    if (!point) return;\n\n    selectBase(editor as any, point);\n\n    return;\n  }\n\n  const at = getAt(editor, target);\n\n  if (!at) return;\n\n  selectBase(editor as any, at);\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { Editor, TLocation } from '../interfaces';\nimport type { QueryNodeOptions } from './queryNode';\n\n/** Query the editor state. */\nexport interface QueryEditorOptions<E extends Editor = Editor>\n  extends Pick<QueryNodeOptions, 'allow' | 'exclude'> {\n  /** Location from where to lookup the node types (bottom-up) */\n  at?: TLocation;\n\n  /** Query the editor. */\n  filter?: (editor: E) => boolean;\n\n  /** When the selection is at the end of the block above. */\n  selectionAtBlockEnd?: boolean;\n\n  /** When the selection is at the start of the block above. */\n  selectionAtBlockStart?: boolean;\n}\n\n/** Query the editor state. */\nexport const queryEditor = <E extends Editor>(\n  editor: E,\n  {\n    allow,\n    at = editor.selection || [],\n    exclude,\n    filter,\n    selectionAtBlockEnd,\n    selectionAtBlockStart,\n  }: QueryEditorOptions<E> = {}\n) => {\n  if (\n    (filter && !filter(editor)) ||\n    (selectionAtBlockStart && !editor.api.isAt({ start: true })) ||\n    (selectionAtBlockEnd && !editor.api.isAt({ end: true }))\n  ) {\n    return false;\n  }\n\n  const allows = castArray(allow);\n\n  if (allows.length > 0 && !editor.api.some({ at, match: { type: allows } })) {\n    return false;\n  }\n\n  const excludes = castArray(exclude);\n\n  if (\n    excludes.length > 0 &&\n    editor.api.some({ at, match: { type: excludes } })\n  ) {\n    return false;\n  }\n\n  return true;\n};\n","import type { NodeEntry, TNode } from '../interfaces';\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/** Filter nodes. */\nexport interface QueryNodeOptions {\n  /** List of types that are valid. If empty or undefined - allow all. */\n  allow?: string[] | string | null;\n\n  /** List of types that are invalid. */\n  exclude?: string[] | string | null;\n\n  /** Query the node entry. */\n  filter?: <N extends TNode>(entry: NodeEntry<N>) => boolean;\n\n  /** Valid path levels. */\n  level?: number[] | number | null;\n\n  /** Paths above that value are invalid. */\n  maxLevel?: number | null;\n}\n\n/** Query the node entry. */\nexport const queryNode = <N extends TNode>(\n  entry?: NodeEntry<N>,\n  { allow, exclude, filter, level, maxLevel }: QueryNodeOptions = {}\n) => {\n  if (!entry) return false;\n\n  const [node, path] = entry;\n\n  if (level) {\n    const levels = castArray(level);\n\n    if (!levels.includes(path.length)) {\n      return false;\n    }\n  }\n  if (maxLevel && path.length > maxLevel) {\n    return false;\n  }\n  if (filter && !filter(entry)) {\n    return false;\n  }\n  if (allow) {\n    const allows = castArray(allow);\n\n    if (allows.length > 0 && !allows.includes(node.type as any)) {\n      return false;\n    }\n  }\n  if (exclude) {\n    const excludes = castArray(exclude);\n\n    if (excludes.length > 0 && excludes.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","/**\n * Iterate through all of the nodes in the editor and return the first match. If\n * no match is found, return undefined.\n */\nimport {\n  type DescendantOf,\n  type Editor,\n  type EditorNodesOptions,\n  type NodeEntry,\n  type NodeEntryOf,\n  type Path,\n  type ValueOf,\n  NodeApi,\n  PathApi,\n  RangeApi,\n  SpanApi,\n} from '../../interfaces';\nimport { match } from '../../utils';\n\nexport const descendant = <\n  N extends DescendantOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>>\n): NodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const {\n      at = editor.selection,\n      match: _match,\n      reverse = false,\n      voids = false,\n    } = options;\n\n    if (!at) return;\n\n    let from;\n    let to;\n\n    if (SpanApi.isSpan(at)) {\n      [from, to] = at;\n    } else if (RangeApi.isRange(at)) {\n      const first = editor.api.path(at, { edge: 'start' });\n      const last = editor.api.path(at, { edge: 'end' });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    let root: NodeEntryOf<E> = [editor, []];\n\n    if (PathApi.isPath(at)) {\n      root = editor.api.node(at) as any;\n    }\n\n    const nodeEntries = NodeApi.descendants<N>(root[0], {\n      from,\n      reverse,\n      to,\n      pass: ([n]) => (voids ? false : editor.api.isVoid(n as any)),\n    });\n\n    for (const [node, path] of nodeEntries) {\n      if (match(node, path, _match as any)) {\n        return [node, (at as Path).concat(path)];\n      }\n    }\n  } catch {\n    return undefined;\n  }\n};\n","import type { Editor } from '../../interfaces/index';\n\nexport const mark = (editor: Editor, key: string) => {\n  const marks = editor.api.marks();\n\n  return (marks as any)?.[key] as unknown;\n};\n","import type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const hasMark = (editor: Editor, key: string) => {\n  return !!editor.api.mark(key);\n};\n","import {\n  type Editor,\n  type EditorIsSelectedOptions,\n  type Path,\n  type TRange,\n  RangeApi,\n} from '../../interfaces';\n\nexport const isSelected = (\n  editor: Editor,\n  target: Path | TRange,\n  options: EditorIsSelectedOptions = {}\n) => {\n  const { contains = false } = options;\n\n  if (!editor.selection) return false;\n\n  const range = RangeApi.isRange(target) ? target : editor.api.range(target);\n\n  if (!range) return false;\n  if (contains) {\n    return RangeApi.contains(editor.selection, range);\n  }\n\n  // Check if selection intersects with path range\n  return !!RangeApi.intersection(editor.selection, range);\n};\n","import type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\n\nimport {\n  type EditorAboveOptions,\n  type TLocation,\n  PathApi,\n  PointApi,\n  RangeApi,\n} from '../../interfaces';\n\n/**\n * Check if a location (point/range) is at a specific position.\n *\n * For ranges:\n *\n * - If text=true, check if range is in single text node\n * - If block=true, check if range is in single block\n * - If blocks=true, check if range is across multiple blocks\n * - If start=true, check if range starts at block start\n * - If end=true, check if range ends at block end\n *\n * For points:\n *\n * - If word=true, check relative to word boundaries\n * - If start=true, check if at start\n * - If end=true, check if at end\n */\nexport const isAt = <E extends Editor>(\n  editor: E,\n  {\n    at = editor.selection,\n    block,\n    blocks,\n    end,\n    start,\n    text,\n    word,\n    ...options\n  }: {\n    /** The location to check. Defaults to current selection */\n    at?: TLocation | null;\n    /** Check if range is in single block */\n    block?: boolean;\n    /** Check if range is across multiple blocks */\n    blocks?: boolean;\n    /** Check if range ends at block end or point is at word end */\n    end?: boolean;\n    /** Check if range starts at block start */\n    start?: boolean;\n    /** Check if range is in single text node */\n    text?: boolean;\n    /** Check if point is at word boundary (only with end=true) */\n    word?: boolean;\n  } & Omit<EditorAboveOptions<ValueOf<E>>, 'at' | 'block'> = {}\n) => {\n  if (!at) return false;\n  // Handle Point\n  if (PointApi.isPoint(at)) {\n    if (word && end) {\n      const after = editor.api.after(at);\n\n      if (!after) return true;\n\n      const afterRange = editor.api.range(at, after);\n      const afterText = editor.api.string(afterRange);\n\n      return /^(?:\\s|$)/.test(afterText);\n    }\n\n    return false;\n  }\n  // Handle Range\n  if (RangeApi.isRange(at)) {\n    const [startPoint, endPoint] = RangeApi.edges(at);\n\n    // Check if range is in single text node\n    if (text) {\n      return PathApi.equals(startPoint.path, endPoint.path);\n    }\n\n    const startBlock = editor.api.block({\n      at: startPoint,\n      ...options,\n    });\n    const endBlock = editor.api.block({\n      at: endPoint,\n      ...options,\n    });\n\n    // Handle blocks edge cases\n    if (blocks) {\n      if (!startBlock && !endBlock) return false;\n      if (!startBlock || !endBlock) return true;\n\n      return !PathApi.equals(startBlock[1], endBlock[1]);\n    }\n    if (!startBlock || !endBlock) return false;\n    // Check if range is in single block\n    if (block) {\n      return PathApi.equals(startBlock[1], endBlock[1]);\n    }\n    // Check block boundaries\n    if (start) {\n      return (\n        editor.api.isStart(startPoint, startBlock[1]) ||\n        (RangeApi.isExpanded(at) && editor.api.isStart(endPoint, startBlock[1]))\n      );\n    }\n    if (end) {\n      return editor.api.isEnd(endPoint, endBlock[1]);\n    }\n  }\n\n  return false;\n};\n","import { type Editor, PathApi } from '../../interfaces/index';\n\nexport const isEditorEnd = (editor: Editor) => {\n  if (editor.selection) {\n    const point = editor.selection.focus;\n    const endPoint = editor.api.end([])!;\n\n    return (\n      endPoint.offset === 0 &&\n      editor.api.isEnd(point, point) &&\n      PathApi.equals(PathApi.next(PathApi.parent(point.path)), endPoint.path)\n    );\n  }\n\n  return false;\n};\n","import type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { TextApi } from '../../interfaces';\n\n/** Check if a node at a location is a Text node */\nexport const isText = (editor: Editor, at: At) => {\n  const node = editor.api.node(at)?.[0];\n\n  return TextApi.isText(node);\n};\n","import type { Editor, NodeEntry } from '../../interfaces/index';\n\nexport const nodesRange = (editor: Editor, nodes: NodeEntry[]) => {\n  if (nodes.length === 0) return;\n\n  const firstBlockPath = nodes[0][1];\n  const lastBlockPath = nodes.at(-1)![1];\n\n  return editor.api.range(firstBlockPath, lastBlockPath);\n};\n","import { type EditorPropOptions, NodeApi } from '../../interfaces';\n\nexport function prop({\n  key,\n  defaultValue,\n  getProp,\n  mode = 'block',\n  nodes,\n}: EditorPropOptions): string | undefined {\n  if (nodes.length === 0) return defaultValue;\n\n  const getNodeValue =\n    getProp ??\n    ((node) => {\n      return node[key!]!;\n    });\n\n  let value: string | undefined;\n\n  for (const node of nodes) {\n    if (mode === 'block' || mode === 'all') {\n      const nodeValue = getNodeValue(node);\n\n      if (nodeValue !== undefined) {\n        if (value === undefined) {\n          value = nodeValue;\n        } else if (value !== nodeValue) {\n          return;\n        }\n        if (mode === 'block') continue;\n      } else if (mode === 'block') {\n        return defaultValue;\n      }\n    }\n    if (mode === 'text' || mode === 'all') {\n      const textEntries = Array.from(NodeApi.texts(node));\n\n      for (const [text] of textEntries) {\n        const textValue = getNodeValue(text);\n\n        if (textValue !== undefined) {\n          if (value === undefined) {\n            value = textValue;\n          } else if (value !== textValue) {\n            return;\n          }\n        } else if (mode === 'text') {\n          return defaultValue;\n        }\n      }\n    }\n  }\n\n  return value;\n}\n","// Compute what scrolling needs to be done on required scrolling boxes for target to be in view\n\n// The type names here are named after the spec to make it easier to find more information around what they mean:\n// To reduce churn and reduce things that need be maintained things from the official TS DOM library is used here\n// https://drafts.csswg.org/cssom-view/\n\n// For a definition on what is \"block flow direction\" exactly, check this: https://drafts.csswg.org/css-writing-modes-4/#block-flow-direction\n\n/**\n * This new option is tracked in this PR, which is the most likely candidate at the time: https://github.com/w3c/csswg-drafts/pull/1805\n * @public\n */\nexport type ScrollMode = 'always' | 'if-needed'\n\n/** @public */\nexport interface Options {\n  /**\n   * Control the logical scroll position on the y-axis. The spec states that the `block` direction is related to the [writing-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode), but this is not implemented yet in this library.\n   * This means that `block: 'start'` aligns to the top edge and `block: 'end'` to the bottom.\n   * @defaultValue 'center'\n   */\n  block?: ScrollLogicalPosition\n  /**\n   * Like `block` this is affected by the [writing-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode). In left-to-right pages `inline: 'start'` will align to the left edge. In right-to-left it should be flipped. This will be supported in a future release.\n   * @defaultValue 'nearest'\n   */\n  inline?: ScrollLogicalPosition\n  /**\n   * This is a proposed addition to the spec that you can track here: https://github.com/w3c/csswg-drafts/pull/5677\n   *\n   * This library will be updated to reflect any changes to the spec and will provide a migration path.\n   * To be backwards compatible with `Element.scrollIntoViewIfNeeded` if something is not 100% visible it will count as \"needs scrolling\". If you need a different visibility ratio your best option would be to implement an [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).\n   * @defaultValue 'always'\n   */\n  scrollMode?: ScrollMode\n  /**\n   * By default there is no boundary. All the parent elements of your target is checked until it reaches the viewport ([`document.scrollingElement`](https://developer.mozilla.org/en-US/docs/Web/API/document/scrollingElement)) when calculating layout and what to scroll.\n   * By passing a boundary you can short-circuit this loop depending on your needs:\n   * \n   * - Prevent the browser window from scrolling.\n   * - Scroll elements into view in a list, without scrolling container elements.\n   * \n   * You can also pass a function to do more dynamic checks to override the scroll scoping:\n   * \n   * ```js\n   * let actions = compute(target, {\n   *   boundary: (parent) => {\n   *     // By default `overflow: hidden` elements are allowed, only `overflow: visible | clip` is skipped as\n   *     // this is required by the CSSOM spec\n   *     if (getComputedStyle(parent)['overflow'] === 'hidden') {\n   *       return false\n   *     }\n\n   *     return true\n   *   },\n   * })\n   * ```\n   * @defaultValue null\n   */\n  boundary?: Element | ((parent: Element) => boolean) | null\n  /**\n   * New option that skips auto-scrolling all nodes with overflow: hidden set\n   * See FF implementation: https://hg.mozilla.org/integration/fx-team/rev/c48c3ec05012#l7.18\n   * @defaultValue false\n   * @public\n   */\n  skipOverflowHiddenElements?: boolean\n}\n\n/** @public */\nexport interface ScrollAction {\n  el: Element\n  top: number\n  left: number\n}\n\n// @TODO better shadowdom test, 11 = document fragment\nconst isElement = (el: any): el is Element =>\n  typeof el === 'object' && el != null && el.nodeType === 1\n\nconst canOverflow = (\n  overflow: string | null,\n  skipOverflowHiddenElements?: boolean\n) => {\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\n    return false\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip'\n}\n\nconst getFrameElement = (el: Element) => {\n  if (!el.ownerDocument || !el.ownerDocument.defaultView) {\n    return null\n  }\n\n  try {\n    return el.ownerDocument.defaultView.frameElement\n  } catch (e) {\n    return null\n  }\n}\n\nconst isHiddenByFrame = (el: Element): boolean => {\n  const frame = getFrameElement(el)\n  if (!frame) {\n    return false\n  }\n\n  return (\n    frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth\n  )\n}\n\nconst isScrollable = (el: Element, skipOverflowHiddenElements?: boolean) => {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    const style = getComputedStyle(el, null)\n    return (\n      canOverflow(style.overflowY, skipOverflowHiddenElements) ||\n      canOverflow(style.overflowX, skipOverflowHiddenElements) ||\n      isHiddenByFrame(el)\n    )\n  }\n\n  return false\n}\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n *      \n *  target    frame\n *      \n */\nconst alignNearest = (\n  scrollingEdgeStart: number,\n  scrollingEdgeEnd: number,\n  scrollingSize: number,\n  scrollingBorderStart: number,\n  scrollingBorderEnd: number,\n  elementEdgeStart: number,\n  elementEdgeEnd: number,\n  elementSize: number\n) => {\n  /**\n   * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n   *\n   *          \n   *        \n   *            \n   *                    do nothing\n   *            \n   *        \n   *          \n   *\n   *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n   *\n   *         \n   *   \n   *                    do nothing\n   *   \n   *         \n   */\n  if (\n    (elementEdgeStart < scrollingEdgeStart &&\n      elementEdgeEnd > scrollingEdgeEnd) ||\n    (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n  ) {\n    return 0\n  }\n\n  /**\n   * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n   *\n   *          \n   *                 \n   *                         \n   *  from             to    \n   *\n   *                     \n   *\n   * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n   *\n   *                   \n   *                             \n   *  from         to      \n   *                           \n   *                 \n   *                         \n   *            \n   *          \n   *\n   * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n   *\n   *       from                 to\n   *                       \n   *                   \n   *                            \n   *                   \n   *                       \n   *\n   * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n   *\n   *       from                 to\n   *                       \n   *           \n   *                              \n   *           \n   *                       \n   */\n  if (\n    (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n    (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n  ) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart\n  }\n\n  /**\n   * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n   *\n   *                     \n   *\n   *  from             to    \n   *                         \n   *                 \n   *          \n   *\n   * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n   *\n   *          \n   *            \n   *                         \n   *                 \n   *                           \n   *  from         to      \n   *                             \n   *                   \n   *\n   * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n   *\n   *           from                 to\n   *                           \n   *             \n   *                                \n   *             \n   *                           \n   *\n   * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n   *\n   *           from                 to\n   *                           \n   *                             \n   *                                \n   *                             \n   *                           \n   *\n   */\n  if (\n    (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n    (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n  ) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd\n  }\n\n  return 0\n}\n\nconst getParentElement = (element: Node): Element | null => {\n  const parent = element.parentElement\n  if (parent == null) {\n    return (element.getRootNode() as ShadowRoot).host || null\n  }\n  return parent\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n/** @public */\nexport const compute = (target: Element, options: Options): ScrollAction[] => {\n  if (typeof document === 'undefined') {\n    // If there's no DOM we assume it's not in a browser environment\n    return []\n  }\n\n  const { scrollMode, block, inline, boundary, skipOverflowHiddenElements } =\n    options\n  // Allow using a callback to check the boundary\n  // The default behavior is to check if the current target matches the boundary element or not\n  // If undefined it'll check that target is never undefined (can happen as we recurse up the tree)\n  const checkBoundary =\n    typeof boundary === 'function' ? boundary : (node: any) => node !== boundary\n\n  if (!isElement(target)) {\n    throw new TypeError('Invalid target')\n  }\n\n  // Used to handle the top most element that can be scrolled\n  const scrollingElement = document.scrollingElement || document.documentElement\n\n  // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n  const frames: Element[] = []\n  let cursor: Element | null = target\n  while (isElement(cursor) && checkBoundary(cursor)) {\n    // Move cursor to parent\n    cursor = getParentElement(cursor)\n\n    // Stop when we reach the viewport\n    if (cursor === scrollingElement) {\n      frames.push(cursor)\n      break\n    }\n\n    // Skip document.body if it's not the scrollingElement and documentElement isn't independently scrollable\n    if (\n      cursor != null &&\n      cursor === document.body &&\n      isScrollable(cursor) &&\n      !isScrollable(document.documentElement)\n    ) {\n      continue\n    }\n\n    // Now we check if the element is scrollable, this code only runs if the loop haven't already hit the viewport or a custom boundary\n    if (cursor != null && isScrollable(cursor, skipOverflowHiddenElements)) {\n      frames.push(cursor)\n    }\n  }\n\n  // Support pinch-zooming properly, making sure elements scroll into the visual viewport\n  // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n  // and viewport dimensions on window.innerWidth/Height\n  // https://www.quirksmode.org/mobile/viewports2.html\n  // https://bokand.github.io/viewport/index.html\n  const viewportWidth = window.visualViewport?.width ?? innerWidth\n  const viewportHeight = window.visualViewport?.height ?? innerHeight\n  const { scrollX, scrollY } = window\n\n  const {\n    height: targetHeight,\n    width: targetWidth,\n    top: targetTop,\n    right: targetRight,\n    bottom: targetBottom,\n    left: targetLeft,\n  } = target.getBoundingClientRect()\n  const {\n    top: marginTop,\n    right: marginRight,\n    bottom: marginBottom,\n    left: marginLeft,\n  } = getScrollMargins(target)\n\n  // These values mutate as we loop through and generate scroll coordinates\n  let targetBlock: number =\n    block === 'start' || block === 'nearest'\n      ? targetTop - marginTop\n      : block === 'end'\n      ? targetBottom + marginBottom\n      : targetTop + targetHeight / 2 - marginTop + marginBottom // block === 'center\n  let targetInline: number =\n    inline === 'center'\n      ? targetLeft + targetWidth / 2 - marginLeft + marginRight\n      : inline === 'end'\n      ? targetRight + marginRight\n      : targetLeft - marginLeft // inline === 'start || inline === 'nearest\n\n  // Collect new scroll positions\n  const computations: ScrollAction[] = []\n  // In chrome there's no longer a difference between caching the `frames.length` to a var or not, so we don't in this case (size > speed anyways)\n  for (let index = 0; index < frames.length; index++) {\n    const frame = frames[index]\n\n    // @TODO add a shouldScroll hook here that allows userland code to take control\n\n    const { height, width, top, right, bottom, left } =\n      frame.getBoundingClientRect()\n\n    // If the element is already visible we can end it here\n    // @TODO targetBlock and targetInline should be taken into account to be compliant with https://github.com/w3c/csswg-drafts/pull/1805/files#diff-3c17f0e43c20f8ecf89419d49e7ef5e0R1333\n    if (\n      scrollMode === 'if-needed' &&\n      targetTop >= 0 &&\n      targetLeft >= 0 &&\n      targetBottom <= viewportHeight &&\n      targetRight <= viewportWidth &&\n      // scrollingElement is added to the frames array even if it's not scrollable, in which case checking its bounds is not required\n      ((frame === scrollingElement && !isScrollable(frame)) ||\n        (targetTop >= top &&\n          targetBottom <= bottom &&\n          targetLeft >= left &&\n          targetRight <= right))\n    ) {\n      // Break the loop and return the computations for things that are not fully visible\n      return computations\n    }\n\n    const frameStyle = getComputedStyle(frame)\n    const borderLeft = parseInt(frameStyle.borderLeftWidth as string, 10)\n    const borderTop = parseInt(frameStyle.borderTopWidth as string, 10)\n    const borderRight = parseInt(frameStyle.borderRightWidth as string, 10)\n    const borderBottom = parseInt(frameStyle.borderBottomWidth as string, 10)\n\n    let blockScroll: number = 0\n    let inlineScroll: number = 0\n\n    // The property existance checks for offfset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n    // @TODO find out if the \"as HTMLElement\" overrides can be dropped\n    const scrollbarWidth =\n      'offsetWidth' in frame\n        ? (frame as HTMLElement).offsetWidth -\n          (frame as HTMLElement).clientWidth -\n          borderLeft -\n          borderRight\n        : 0\n    const scrollbarHeight =\n      'offsetHeight' in frame\n        ? (frame as HTMLElement).offsetHeight -\n          (frame as HTMLElement).clientHeight -\n          borderTop -\n          borderBottom\n        : 0\n\n    const scaleX =\n      'offsetWidth' in frame\n        ? (frame as HTMLElement).offsetWidth === 0\n          ? 0\n          : width / (frame as HTMLElement).offsetWidth\n        : 0\n    const scaleY =\n      'offsetHeight' in frame\n        ? (frame as HTMLElement).offsetHeight === 0\n          ? 0\n          : height / (frame as HTMLElement).offsetHeight\n        : 0\n\n    if (scrollingElement === frame) {\n      // Handle viewport logic (document.documentElement or document.body)\n\n      if (block === 'start') {\n        blockScroll = targetBlock\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          scrollY,\n          scrollY + viewportHeight,\n          viewportHeight,\n          borderTop,\n          borderBottom,\n          scrollY + targetBlock,\n          scrollY + targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - viewportHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(\n          scrollX,\n          scrollX + viewportWidth,\n          viewportWidth,\n          borderLeft,\n          borderRight,\n          scrollX + targetInline,\n          scrollX + targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      // Apply scroll position offsets and ensure they are within bounds\n      // @TODO add more test cases to cover this 100%\n      blockScroll = Math.max(0, blockScroll + scrollY)\n      inlineScroll = Math.max(0, inlineScroll + scrollX)\n    } else {\n      // Handle each scrolling frame that might exist between the target and the viewport\n      if (block === 'start') {\n        blockScroll = targetBlock - top - borderTop\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          top,\n          bottom,\n          height,\n          borderTop,\n          borderBottom + scrollbarHeight,\n          targetBlock,\n          targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - left - borderLeft\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(\n          left,\n          right,\n          width,\n          borderLeft,\n          borderRight + scrollbarWidth,\n          targetInline,\n          targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      const { scrollLeft, scrollTop } = frame\n      // Ensure scroll coordinates are not out of bounds while applying scroll offsets\n      blockScroll =\n        scaleY === 0\n          ? 0\n          : Math.max(\n              0,\n              Math.min(\n                scrollTop + blockScroll / scaleY,\n                frame.scrollHeight - height / scaleY + scrollbarHeight\n              )\n            )\n      inlineScroll =\n        scaleX === 0\n          ? 0\n          : Math.max(\n              0,\n              Math.min(\n                scrollLeft + inlineScroll / scaleX,\n                frame.scrollWidth - width / scaleX + scrollbarWidth\n              )\n            )\n\n      // Cache the offset so that parent frames can scroll this into view correctly\n      targetBlock += scrollTop - blockScroll\n      targetInline += scrollLeft - inlineScroll\n    }\n\n    computations.push({ el: frame, top: blockScroll, left: inlineScroll })\n  }\n\n  return computations\n}\n","import { compute } from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/**\n * Only scrolls if the `node` is partially out of view:\n * ```ts\n * scrollIntoView(node, { scrollMode: 'if-needed' })\n * ```\n * Skips scrolling `overflow: hidden` elements:\n * ```ts\n * scrollIntoView(node, { skipOverflowHiddenElements: true })\n * ```\n * When scrolling is needed do the least and smoothest scrolling possible:\n * ```ts\n * scrollIntoView(node, {\n *   behavior: 'smooth',\n *   scrollMode: 'if-needed',\n *   block: 'nearest',\n *   inline: 'nearest',\n * })\n * ```\n * @public\n */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nconst isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nconst isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nconst getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n// Determine if the element is part of the document (including shadow dom)\n// Derived from code of Andy Desmarais\n// https://terodox.tech/how-to-tell-if-an-element-is-in-the-dom-including-the-shadow-dom/\nconst isInDocument = (element: Node) => {\n  let currentElement = element\n  while (currentElement && currentElement.parentNode) {\n    if (currentElement.parentNode === document) {\n      return true\n    } else if (currentElement.parentNode instanceof ShadowRoot) {\n      currentElement = (currentElement.parentNode as ShadowRoot).host\n    } else {\n      currentElement = currentElement.parentNode\n    }\n  }\n  return false\n}\n\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n * @public\n */\nfunction scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n *\n * You can set the expected return type for `behavior: Function`:\n * ```ts\n * await scrollIntoView<Promise<boolean[]>>(node, {\n *   behavior: async actions => {\n *     return Promise.all(actions.map(\n *       // animate() resolves to `true` if anything was animated, `false` if the element already were in the end state\n *       ({ el, left, top }) => animate(el, {scroll: {left, top}})\n *     ))\n *   }\n * })\n * ```\n * @public\n */\nfunction scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\nfunction scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  if (!target.isConnected || !isInDocument(target)) {\n    return\n  }\n\n  const margins = getScrollMargins(target)\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(compute(target, options))\n  }\n\n  const behavior = typeof options === 'boolean' ? undefined : options?.behavior\n\n  for (const { el, top, left } of compute(target, getOptions(options))) {\n    const adjustedTop = top - margins.top + margins.bottom\n    const adjustedLeft = left - margins.left + margins.right\n    el.scroll({ top: adjustedTop, left: adjustedLeft, behavior })\n  }\n}\n\nexport default scrollIntoView\n","import scrollIntoViewIfNeeded from 'scroll-into-view-if-needed';\n\nimport type { Editor } from '../../interfaces/editor';\nimport type { ScrollIntoViewOptions } from '../../interfaces/scroll';\nimport type { DOMRange } from '../../slate-dom';\n\nimport { type Point, PointApi } from '../../interfaces/point';\n\nconst defaultOptions: ScrollIntoViewOptions = {\n  scrollMode: 'if-needed',\n};\n\n// TODO: move to slate\nexport function scrollIntoView(\n  editor: Editor,\n  target: DOMRange | Point,\n  options: ScrollIntoViewOptions = defaultOptions\n): void {\n  requestAnimationFrame(() => {\n    let domRange: DOMRange | undefined;\n\n    if (PointApi.isPoint(target)) {\n      const { offset = 0, path } = target;\n\n      domRange = editor.api.toDOMRange({\n        anchor: { offset, path },\n        focus: { offset, path },\n      });\n    } else {\n      domRange = target;\n    }\n\n    if (!domRange) return;\n\n    const leafEl = domRange.startContainer.parentElement!;\n\n    leafEl.getBoundingClientRect =\n      domRange.getBoundingClientRect.bind(domRange);\n    scrollIntoViewIfNeeded(leafEl, options);\n\n    setTimeout(() => delete (leafEl as any).getBoundingClientRect, 0);\n  });\n}\n","import type {\n  Editor,\n  EditorNodesOptions,\n  ValueOf,\n} from '../../interfaces/index';\n\n/**\n * Iterate through all of the nodes in the editor and break early for the first\n * truthy match. Otherwise returns false.\n */\nexport const some = <E extends Editor = Editor>(\n  editor: E,\n  options: EditorNodesOptions<ValueOf<E>>\n) => {\n  return !!editor.api.node(options);\n};\n","import { above as aboveBase } from 'slate';\n\nimport type { AncestorOf, EditorAboveOptions } from '../../interfaces';\nimport type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport { getQueryOptions } from '../../utils/match';\n\nexport const above = <N extends AncestorOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorAboveOptions<ValueOf<E>>\n): NodeEntry<N> | undefined => {\n  try {\n    return aboveBase(editor as any, getQueryOptions(editor, options)) as any;\n  } catch {\n    return undefined;\n  }\n};\n","import { addMark as addMarkBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const addMark = (editor: Editor, key: string, value: any) =>\n  addMarkBase(editor as any, key, value);\n","import type { EditorRangeRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { rangeRef } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TRange } from '../../interfaces/range';\n\nexport const createRangeRef = (\n  editor: Editor,\n  range: TRange,\n  options?: EditorRangeRefOptions\n) => rangeRef(editor as any, range, options as any);\n","import { deleteBackward as deleteBackwardBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TextUnit } from '../../types';\n\nexport const deleteBackward = (\n  editor: Editor,\n  unit: TextUnit = 'character'\n) => {\n  deleteBackwardBase(editor as any, unit);\n};\n","import { deleteForward as deleteForwardBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TextUnit } from '../../types';\n\nexport const deleteForward = (editor: Editor, unit: TextUnit = 'character') => {\n  deleteForwardBase(editor as any, unit);\n};\n","import type { EditorFragmentDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { deleteFragment as deleteFragmentBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const deleteFragment = (\n  editor: Editor,\n  options?: EditorFragmentDeletionOptions\n) => deleteFragmentBase(editor as any, options);\n","import { node as nodeBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\nimport type { AtOrDescendant } from '../../types';\n\nimport {\n  type DescendantOf,\n  type EditorNodeOptions,\n  type EditorNodesOptions,\n  type ValueOf,\n  LocationApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\n\nexport const node = <N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  atOrOptions: AtOrDescendant | EditorNodesOptions<ValueOf<E>>,\n  nodeOptions?: EditorNodeOptions\n): NodeEntry<N> | undefined => {\n  try {\n    if (LocationApi.isAt(atOrOptions)) {\n      const at = getAt(editor, atOrOptions)!;\n\n      return nodeBase(editor as any, at, nodeOptions) as any;\n    }\n\n    const options = atOrOptions;\n\n    const nodeEntries = editor.api.nodes<N>(options);\n\n    return nodeEntries.next().value as any;\n  } catch {\n    return undefined;\n  }\n};\n","import { type EditorPathOptions, path as pathBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const path = (editor: Editor, at: At, options?: EditorPathOptions) => {\n  try {\n    return pathBase(editor as any, getAt(editor, at)!, options as any);\n  } catch {}\n};\n","import { edges } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const getEdgePoints = (editor: Editor, at: At) => {\n  try {\n    return edges(editor as any, getAt(editor, at)!);\n  } catch {}\n};\n","import { string } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorStringOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const getEditorString = (\n  editor: Editor,\n  at: At | null = editor.selection,\n  options?: EditorStringOptions\n) => {\n  if (!at) return '';\n\n  try {\n    return string(editor as any, getAt(editor, at)!, options);\n  } catch {\n    return '';\n  }\n};\n","import { first } from 'slate';\n\nimport type { DescendantOf, NodeEntry } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getFirstNode = <N extends DescendantOf<E>, E extends Editor>(\n  editor: E,\n  at: At\n): NodeEntry<N> | undefined => {\n  try {\n    return first(editor as any, getAt(editor, at)!) as any;\n  } catch {}\n};\n","import { fragment, getFragment as getFragmentBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { ElementOrTextOf, TElement } from '../../interfaces/element';\nimport type { EditorFragmentOptions } from '../../interfaces/index';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nconst unwrapStructuralNodes = (\n  nodes: TElement[],\n  { structuralTypes }: { structuralTypes?: string[] } = {}\n) => {\n  const unwrap = (nodes: TElement[], acc: TElement[] = []): TElement[] => {\n    nodes.forEach((node) => {\n      if (structuralTypes?.includes(node.type)) {\n        return unwrap(node.children as TElement[], acc);\n      }\n\n      acc.push(node);\n    });\n\n    return acc;\n  };\n\n  return unwrap(nodes);\n};\n\nexport const getFragment = <E extends Editor>(\n  editor: E,\n  at?: At | null,\n  options?: EditorFragmentOptions\n): ElementOrTextOf<E>[] => {\n  if (at === null) return [];\n\n  try {\n    const result =\n      at === undefined\n        ? (getFragmentBase(editor as any) as any)\n        : (fragment(editor as any, getAt(editor, at)!) as any);\n\n    if (result.length > 0 && options?.structuralTypes) {\n      return unwrapStructuralNodes(result, options) as any;\n    }\n\n    return result;\n  } catch {\n    return [];\n  }\n};\n","import { levels } from 'slate';\n\nimport type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { EditorLevelsOptions } from '../../interfaces/index';\nimport type { NodeOf } from '../../interfaces/node';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport { getQueryOptions } from '../../utils';\n\nexport const getLevels = <N extends NodeOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorLevelsOptions<ValueOf<E>>\n): Generator<NodeEntry<N>, void, undefined> => {\n  return levels(editor as any, getQueryOptions(editor, options)) as any;\n};\n","import { marks } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { MarksOf } from '../../interfaces/text';\n\nexport const getMarks = <E extends Editor>(editor: E) =>\n  marks(editor as any) as MarksOf<E> | null;\n","import { pathRefs } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const getPathRefs = (editor: Editor) => pathRefs(editor as any);\n","import { type EditorPointOptions, point } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const getPoint = (\n  editor: Editor,\n  at: At,\n  options?: EditorPointOptions\n) => {\n  try {\n    return point(editor as any, getAt(editor, at)!, options as any);\n  } catch {}\n};\n","import { pointRefs } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const getPointRefs = (editor: Editor) => pointRefs(editor as any);\n","import { positions } from 'slate';\n\nimport type { EditorPositionsOptions } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nimport { getAt } from '../../utils';\n\nexport const getPositions = (\n  editor: Editor,\n  options?: EditorPositionsOptions\n) =>\n  positions(editor as any, {\n    ...options,\n    at: getAt(editor, options?.at),\n  });\n","import { rangeRefs } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const getRangeRefs = (editor: Editor) => rangeRefs(editor as any);\n","import { hasBlocks as hasBlocksBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TElement } from '../../interfaces/element';\n\nexport const hasBlocks = (editor: Editor, element: TElement) =>\n  hasBlocksBase(editor as any, element);\n","import { hasInlines as hasInlinesBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TElement } from '../../interfaces/element';\n\nexport const hasInlines = (editor: Editor, element: TElement) =>\n  hasInlinesBase(editor as any, element);\n","import { hasTexts as hasTextsBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TElement } from '../../interfaces/element';\n\nexport const hasTexts = (editor: Editor, element: TElement) =>\n  hasTextsBase(editor as any, element);\n","import { insertBreak as insertBreakBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const insertBreak = (editor: Editor) => insertBreakBase(editor as any);\n","import type { DescendantOf, InsertNodesOptions } from '../../interfaces';\nimport type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\n\nexport const insertNode = <\n  N extends DescendantOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  node: N,\n  options?: InsertNodesOptions<ValueOf<E>>\n) => editor.tf.insertNodes(node, options);\n","import { isEdge } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TLocation } from '../../interfaces/index';\nimport type { Point } from '../../interfaces/point';\n\nexport const isEdgePoint = (editor: Editor, point: Point, at: TLocation) =>\n  isEdge(editor as any, point, at);\n","import { isNormalizing } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const isEditorNormalizing = (editor: Editor) =>\n  isNormalizing(editor as any);\n","import { elementReadOnly } from 'slate';\n\nimport type { EditorElementReadOnlyOptions } from '../../interfaces';\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const isElementReadOnly = <E extends Editor = Editor>(\n  editor: E,\n  options?: EditorElementReadOnlyOptions\n) => elementReadOnly(editor as any, options);\n","import { isEmpty as isEmptyBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport {\n  type EditorEmptyOptions,\n  NodeApi,\n  PathApi,\n  TextApi,\n} from '../../interfaces';\n\nexport const isEmpty = <E extends Editor>(\n  editor: E,\n  target: At | null = [],\n  options?: EditorEmptyOptions\n) => {\n  if (target === null) return true;\n  if (\n    (PathApi.isPath(target) && target.length === 0) ||\n    NodeApi.isEditor(target)\n  ) {\n    return (\n      editor.children.length === 1 &&\n      isEmptyBase(editor as any, editor.children[0] as any)\n    );\n  }\n  if (options?.after) {\n    const blockAbove = editor.api.block({ above: true, at: target });\n\n    if (!blockAbove) return false;\n\n    const point = editor.api.point(target)!;\n    const selectionParentEntry = editor.api.parent(target);\n\n    if (!selectionParentEntry) return false;\n\n    const [, selectionParentPath] = selectionParentEntry;\n\n    if (!editor.api.isEnd(point, selectionParentPath)) return false;\n\n    const siblingNodes = Array.from(\n      NodeApi.children(editor, blockAbove[1], {\n        from: PathApi.lastIndex(point.path) + 1,\n      })\n    ).map(([node]) => node);\n\n    if (siblingNodes.length > 0) {\n      for (const siblingNode of siblingNodes) {\n        if (TextApi.isText(siblingNode) && siblingNode.text) {\n          return false;\n        }\n      }\n    } else {\n      return editor.api.isEnd(point, blockAbove[1]);\n    }\n\n    return true;\n  }\n  if (PathApi.isPath(target)) {\n    return isEmptyBase(editor as any, editor.api.node(target)?.[0] as any);\n  }\n  if (options?.block) {\n    const block = editor.api.block({ at: target });\n\n    if (!block) return false;\n\n    target = block[0];\n  }\n  if (!NodeApi.isNode(target)) {\n    const nodes = editor.api.nodes({ at: target, ...options });\n\n    for (const node of nodes) {\n      if (!isEmptyBase(editor as any, node[0] as any)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return isEmptyBase(editor as any, target as any);\n};\n","import { isEnd } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TLocation } from '../../interfaces/index';\nimport type { Point } from '../../interfaces/point';\n\nexport const isEndPoint = (\n  editor: Editor,\n  point: Point | null | undefined,\n  at: TLocation\n) => !!point && isEnd(editor as any, point, at);\n","import { isStart } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { TLocation } from '../../interfaces/index';\nimport type { Point } from '../../interfaces/point';\n\nexport const isStartPoint = (\n  editor: Editor,\n  point: Point | null | undefined,\n  at: TLocation\n) => !!point && isStart(editor as any, point, at);\n","import { last as lastBase } from 'slate';\n\nimport type {\n  DescendantOf,\n  Editor,\n  EditorLastOptions,\n  NodeEntry,\n} from '../../interfaces';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nconst getNodeAtLevel = (\n  editor: Editor,\n  [node, path]: NodeEntry,\n  level: number\n): NodeEntry => {\n  // Get the path at the desired level\n  const levelPath = path.slice(0, level + 1);\n\n  // Get the node at that path\n  const entry = editor.api.node(levelPath);\n\n  if (!entry) return [node, path];\n\n  return entry;\n};\n\nexport const last = <N extends DescendantOf<E>, E extends Editor>(\n  editor: E,\n  at: At,\n  options: EditorLastOptions = {}\n): NodeEntry<N> | undefined => {\n  try {\n    const { level } = options;\n\n    const lastNodeEntry = lastBase(\n      editor as any,\n      getAt(editor, at)!\n    ) as NodeEntry<N>;\n\n    // If level is specified, get the node at that level\n    if (lastNodeEntry && typeof level === 'number') {\n      if (editor.children.length === 0) {\n        return;\n      }\n\n      return getNodeAtLevel(editor, lastNodeEntry, level) as any;\n    }\n\n    return lastNodeEntry;\n  } catch {}\n};\n","import type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport {\n  type DescendantOf,\n  type EditorNextOptions,\n  type Path,\n  type Span,\n  PathApi,\n} from '../../interfaces';\nimport { combineMatch, getAt, getMatch } from '../../utils';\n\nexport const next = <N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options: EditorNextOptions<ValueOf<E>> = {}\n): NodeEntry<N> | undefined => {\n  const {\n    from = 'after',\n    mode = from === 'child' ? 'all' : 'lowest',\n    voids = false,\n  } = options;\n  let match = getMatch(editor, options);\n\n  const at = getAt(editor, options.at) ?? editor.selection;\n\n  if (!at) {\n    return;\n  }\n\n  let start: Path | undefined;\n\n  // FORK: from\n  if (from === 'child' && PathApi.isPath(at)) {\n    const path = PathApi.firstChild(at);\n    const fromNode = editor.api.node(path);\n\n    if (fromNode) {\n      start = path;\n      match = combineMatch((n, p) => {\n        return !PathApi.isAncestor(p, at) && !PathApi.equals(p, at);\n      }, match);\n    }\n  }\n  if (!start) {\n    const pointAfterLocation = editor.api.after(at, { voids })!;\n\n    if (!pointAfterLocation) return;\n\n    start = pointAfterLocation.path;\n  }\n\n  const [, to] = editor.api.last([])!;\n\n  // FORK: from\n  const span: Span = [start, to];\n\n  if (PathApi.isPath(at) && at.length === 0) {\n    // throw new Error(`Cannot get the next node from the root node!`);\n    return;\n  }\n  if (match == null) {\n    if (PathApi.isPath(at)) {\n      const [parent] = editor.api.parent(at)!;\n      match = (n) => parent.children.includes(n as any);\n    } else {\n      match = () => true;\n    }\n  }\n\n  const [next] = editor.api.nodes({ at: span, match, mode, voids });\n\n  return next as any;\n};\n","import { normalize } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorNormalizeOptions } from '../../interfaces/index';\n\nexport const normalizeEditor = (\n  editor: Editor,\n  options?: EditorNormalizeOptions\n) => normalize(editor as any, options);\n","import { parent as parentBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { EditorParentOptions } from '../../interfaces/index';\nimport type { AncestorOf } from '../../interfaces/node';\nimport type { NodeEntry } from '../../interfaces/node-entry';\nimport type { At } from '../../types';\n\nimport { getAt } from '../../utils';\n\nexport const parent = <N extends AncestorOf<E>, E extends Editor = Editor>(\n  editor: E,\n  at: At,\n  options?: EditorParentOptions\n): NodeEntry<N> | undefined => {\n  try {\n    return parentBase(editor as any, getAt(editor, at)!, options) as any;\n  } catch {}\n};\n","import type { Editor, ValueOf } from '../../interfaces/editor/editor-type';\nimport type { NodeEntry } from '../../interfaces/node-entry';\n\nimport {\n  type DescendantOf,\n  type EditorPreviousOptions,\n  type Path,\n  type Span,\n  PathApi,\n} from '../../interfaces';\nimport { combineMatch, getAt, getMatch, getQueryOptions } from '../../utils';\n\n// Slate fork\nconst previousBase = (\n  editor: Editor,\n  options: EditorPreviousOptions<ValueOf<Editor>>\n) => {\n  const { from = 'after', mode = 'lowest', voids = false } = options;\n  let match = getMatch(editor, options);\n\n  const at = getAt(editor, options.at) ?? editor.selection;\n\n  if (!at) {\n    return;\n  }\n\n  let start: Path | undefined;\n\n  // FORK: from\n  if (from === 'parent' && PathApi.isPath(at) && at.length > 1) {\n    start = at;\n\n    match = combineMatch((n, p) => {\n      // We want nodes that:\n      // 1. Are not after our target path\n      // 2. Are not the same as our target path\n      return !PathApi.isAfter(p, at) && !PathApi.equals(p, at);\n    }, match);\n  }\n  if (!start) {\n    const pointBeforeLocation = editor.api.before(at, { voids })!;\n\n    if (!pointBeforeLocation) return;\n\n    start = pointBeforeLocation.path;\n  }\n\n  const [, to] = editor.api.first([])!;\n\n  // The search location is from the start of the document to the path of\n  // the point before the location passed in\n  const span: Span = [start, to];\n\n  if (PathApi.isPath(at) && at.length === 0) {\n    // throw new Error(`Cannot get the previous node from the root node!`);\n    return;\n  }\n  if (match == null) {\n    if (PathApi.isPath(at)) {\n      const [parent] = editor.api.parent(at)!;\n      match = (n) => parent.children.includes(n as any);\n    } else {\n      match = () => true;\n    }\n  }\n\n  const [previous] = editor.api.nodes({\n    at: span,\n    match,\n    mode,\n    reverse: true,\n    voids,\n  });\n\n  return previous;\n};\n\nexport const previous = <N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  options?: EditorPreviousOptions<ValueOf<E>>\n): NodeEntry<N> | undefined => {\n  const getPrevious = (o: EditorPreviousOptions<ValueOf<E>>) => {\n    try {\n      return previousBase(editor as any, o) as any;\n    } catch {}\n  };\n\n  if (options?.sibling) {\n    const path = getQueryOptions(editor, options).at;\n\n    if (!path) return;\n\n    const previousPath = PathApi.previous(path);\n\n    if (!previousPath) return;\n\n    const previousNode = editor.api.node(previousPath);\n\n    return previousNode as NodeEntry<N>;\n  }\n  if (!(options?.id && options?.block)) {\n    return getPrevious(options as any);\n  }\n\n  const block = editor.api.node({\n    id: options.id,\n    at: [],\n  });\n\n  if (!block) return;\n\n  // both id and block are defined\n  return getPrevious({ at: block[1], block: true });\n};\n","import { range as rangeBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\nimport type { At } from '../../types';\n\nimport {\n  type EditorBeforeOptions,\n  type TRange,\n  PointApi,\n  RangeApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\n\nexport const range = (\n  editor: Editor,\n  at: At | 'before' | 'start',\n  to?: At | null,\n  options?: { before?: EditorBeforeOptions }\n): TRange | undefined => {\n  let from = getAt(editor, at);\n\n  if (RangeApi.isRange(from) && !to) {\n    return from;\n  }\n  if (from === 'start') {\n    const path = editor.api.block({ at: to! })?.[1];\n\n    if (!path) return;\n\n    const anchor = editor.api.start(path);\n\n    if (!anchor) return;\n\n    const focus = PointApi.get(to);\n\n    if (!focus) return;\n\n    return { anchor, focus };\n  }\n  if (to && from === 'before') {\n    const anchor = editor.api.before(to, options?.before);\n\n    from = anchor ?? getAt(editor, to);\n  }\n\n  return rangeBase(editor as any, from as any, getAt(editor, to));\n};\n","import { removeMark } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nexport const removeEditorMark = (editor: Editor, key: string) =>\n  removeMark(editor as any, key);\n","import { unhangRange as unhangRangeBase } from 'slate';\n\nimport type { Editor } from '../../interfaces/editor/editor-type';\n\nimport {\n  type EditorUnhangRangeOptions,\n  type TRange,\n  PathApi,\n  RangeApi,\n} from '../../interfaces/index';\n\nexport const unhangRange = (\n  editor: Editor,\n  range: TRange,\n  options: EditorUnhangRangeOptions = {}\n): TRange => {\n  const { character, unhang = true, voids } = options;\n\n  if (!RangeApi.isRange(range)) return range;\n  if (character) {\n    let [start, end] = RangeApi.edges(range);\n\n    if (!PathApi.equals(start.path, end.path)) {\n      if (end.offset === 0) {\n        const pointAfter = editor.api.after(start);\n\n        if (pointAfter) {\n          end = pointAfter;\n        }\n      } else {\n        const pointBefore = editor.api.before(end);\n\n        if (pointBefore) {\n          start = pointBefore;\n        }\n      }\n    }\n\n    return { anchor: start, focus: end };\n  }\n  if (unhang) {\n    return unhangRangeBase(editor as any, range, { voids }) as TRange;\n  }\n\n  return range;\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { AddMarksOptions, Editor, EditorMarks } from '../../interfaces';\n\nexport const addMarks = (\n  editor: Editor,\n  marks: EditorMarks,\n  { remove }: AddMarksOptions = {}\n) => {\n  if (!editor.selection) return;\n\n  editor.tf.withoutNormalizing(() => {\n    editor.tf.removeMarks([\n      ...castArray<string>(remove),\n      ...Object.keys(marks),\n    ]);\n\n    Object.entries(marks).forEach(([key, value]) => {\n      editor.tf.addMark(key, value);\n    });\n  });\n};\n","import {\n  type DuplicateNodesOptions,\n  type Editor,\n  PathApi,\n} from '../../interfaces';\nimport { getAt } from '../../utils';\n\nexport const duplicateNodes = (\n  editor: Editor,\n  { block, nodes, ...options }: DuplicateNodesOptions = {}\n) => {\n  const at = getAt(editor, options.at) ?? editor.selection;\n\n  if (!nodes || !at) return;\n\n  // Use provided nodes or get blocks if block=true\n  const entries = nodes ?? (block ? editor.api.blocks({ at }) : []);\n\n  if (entries.length === 0) return;\n\n  const lastEntry = entries.at(-1)!;\n  const insertPath = PathApi.next(lastEntry[1]);\n  const nodesToInsert = entries.map(([node]) => node);\n\n  editor.tf.insertNodes(nodesToInsert as any, {\n    at: insertPath,\n    ...options,\n  });\n};\n","import castArray from 'lodash/castArray.js';\n\nimport {\n  type Editor,\n  type Path,\n  type RemoveMarksOptions,\n  type TElement,\n  type TNode,\n  RangeApi,\n  TextApi,\n} from '../../interfaces';\n\nexport const removeMarks = (\n  editor: Editor,\n  keys?: string[] | string | null,\n  { at, shouldChange = true, ...options }: RemoveMarksOptions = {}\n) => {\n  const selection = at ?? editor.selection;\n\n  if (!selection) return;\n\n  const match = (node: TNode, path: Path) => {\n    if (!TextApi.isText(node)) {\n      return false; // marks can only be applied to text\n    }\n\n    const [parentNode] = editor.api.parent<TElement>(path)!;\n\n    return (\n      !editor.api.isVoid(parentNode) || editor.api.markableVoid(parentNode)\n    );\n  };\n\n  const expandedSelection = RangeApi.isExpanded(selection);\n  let markAcceptingVoidSelected = false;\n\n  if (!expandedSelection) {\n    const [selectedNode, selectedPath] = editor.api.node(selection)!;\n\n    if (selectedNode && match(selectedNode, selectedPath)) {\n      const [parentNode] = editor.api.parent<TElement>(selectedPath)!;\n      markAcceptingVoidSelected =\n        parentNode && editor.api.markableVoid(parentNode);\n    }\n  }\n  if (keys && (expandedSelection || markAcceptingVoidSelected)) {\n    const props = castArray(keys);\n\n    editor.tf.unsetNodes(props, {\n      at: selection,\n      match,\n      split: true,\n      voids: true,\n      ...options,\n    });\n  } else if (!at) {\n    // Only modify editor.marks when no custom range is provided and selection is collapsed\n    const marks = { ...editor.api.marks() };\n\n    if (keys) {\n      castArray(keys).forEach((k) => {\n        delete marks[k];\n      });\n      editor.marks = marks;\n    } else {\n      editor.marks = {};\n    }\n\n    // Slate does not export FLUSHING so we need to call onChange manually\n    shouldChange && editor.api.onChange();\n  }\n};\n","import type {\n  Editor,\n  ElementOrTextOf,\n  ReplaceNodesOptions,\n  ValueOf,\n} from '../../interfaces';\n\nimport { getAt } from '../../utils';\n\nexport const replaceNodes = <\n  N extends ElementOrTextOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  nodes: N | N[],\n  {\n    at,\n    children,\n    removeNodes: removeOptions,\n    ...options\n  }: ReplaceNodesOptions<ValueOf<E>>\n) => {\n  editor.tf.withoutNormalizing(() => {\n    if (children) {\n      if (!at) return;\n\n      at = getAt(editor, at);\n\n      const path = editor.api.path(at!);\n\n      if (!path) return;\n\n      // Remove all children at path\n      editor.tf.removeNodes({\n        ...removeOptions,\n        at: path,\n        children: true,\n      });\n\n      // Insert at first child position\n      editor.tf.insertNodes(nodes, {\n        ...options,\n        at: path.concat([0]),\n      });\n    } else {\n      // Replace node at path\n      editor.tf.removeNodes({ ...removeOptions, at });\n\n      editor.tf.insertNodes(nodes, {\n        ...options,\n        at,\n      });\n    }\n  });\n};\n","import type { Editor, ResetOptions } from '../../interfaces';\n\nexport const reset = (editor: Editor, options: ResetOptions = {}) => {\n  editor.tf.replaceNodes(editor.api.create.value(), {\n    at: [],\n    children: true,\n    ...options,\n  } as any);\n\n  if (!options.children) {\n    editor.operations = [];\n    editor.marks = null;\n\n    if (editor.history?.undos) {\n      editor.history.undos = [];\n      editor.history.redos = [];\n    }\n  }\n};\n","import type { Editor, TElement, ToggleBlockOptions } from '../../interfaces';\n\nexport const toggleBlock = (\n  editor: Editor,\n  type: string,\n  {\n    defaultType: defaultTypeProp,\n    someOptions,\n    wrap,\n    ...options\n  }: ToggleBlockOptions = {}\n) => {\n  const at = options.at ?? editor.selection;\n\n  if (!at) return;\n\n  const isActive = editor.api.some({\n    at,\n    ...someOptions,\n    match: { type },\n  });\n\n  if (wrap) {\n    if (isActive) {\n      editor.tf.unwrapNodes({ at, match: { type } });\n    } else {\n      editor.tf.wrapNodes({ children: [], type }, { at });\n    }\n\n    return;\n  }\n\n  const defaultType = defaultTypeProp ?? editor.api.create.block().type ?? 'p';\n\n  if (isActive && type === defaultType) return;\n\n  editor.tf.setNodes<TElement>(\n    {\n      type: isActive ? defaultType : type,\n    },\n    { at: at as any, ...options }\n  );\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { Editor, ToggleMarkOptions } from '../../interfaces';\n\n/** Add or remove mark in the selection. */\nexport const toggleMark = (\n  editor: Editor,\n  key: string,\n  { remove }: ToggleMarkOptions = {}\n) => {\n  if (!editor.selection) return;\n\n  editor.tf.withoutNormalizing(() => {\n    if (editor.api.hasMark(key)) {\n      editor.tf.removeMark(key);\n\n      return;\n    }\n\n    editor.tf.removeMarks([...castArray<string>(remove), key]);\n\n    editor.tf.addMark(key, true);\n  });\n};\n","import type { SelectionCollapseOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { collapse } from 'slate';\n\nimport type { Editor } from '../../interfaces';\n\nexport const collapseSelection = (\n  editor: Editor,\n  options?: SelectionCollapseOptions\n) => {\n  collapse(editor as any, options);\n};\n","import { deleteText as deleteTextBase } from 'slate';\n\nimport type { DeleteTextOptions, Editor } from '../../interfaces';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const deleteText = <E extends Editor>(\n  editor: E,\n  options?: DeleteTextOptions\n) => {\n  deleteTextBase(editor as any, {\n    ...options,\n    at: getAt(editor, options?.at),\n  });\n};\n","import { deselect as deselectBase } from 'slate';\n\nimport type { Editor } from '../../interfaces';\n\nexport const deselect = (editor: Editor) => {\n  deselectBase(editor as any);\n};\n","import { insertFragment as insertFragmentBase } from 'slate';\n\nimport type {\n  Editor,\n  ElementOrTextOf,\n  InsertFragmentOptions,\n} from '../../interfaces';\n\nimport { getAt } from '../../utils/getAt';\n\nexport const insertFragment = <\n  N extends ElementOrTextOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  fragment: N[],\n  options?: InsertFragmentOptions\n) => {\n  insertFragmentBase(editor as any, fragment, {\n    ...options,\n    at: getAt(editor, options?.at),\n  });\n};\n","import { insertNodes as insertNodesBase } from 'slate';\n\nimport {\n  type Descendant,\n  type Editor,\n  type ElementOrTextOf,\n  type InsertNodesOptions,\n  type ValueOf,\n  NodeApi,\n  PathApi,\n} from '../../interfaces';\nimport { type QueryNodeOptions, getQueryOptions, queryNode } from '../../utils';\n\nexport const insertNodes = <\n  N extends ElementOrTextOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  nodes: N | N[],\n  { nextBlock, removeEmpty, ...options }: InsertNodesOptions<ValueOf<E>> = {}\n) => {\n  options = getQueryOptions(editor, options);\n\n  editor.tf.withoutNormalizing(() => {\n    if (removeEmpty) {\n      const blockEntry = editor.api.above({ at: options.at });\n\n      if (blockEntry) {\n        const queryNodeOptions: QueryNodeOptions =\n          removeEmpty === true\n            ? {\n                allow: ['p'],\n              }\n            : removeEmpty;\n\n        const { filter } = queryNodeOptions;\n\n        queryNodeOptions.filter = ([node, path]) => {\n          if (NodeApi.string(node)) return false;\n\n          const children = node.children as Descendant[];\n\n          if (children.some((n) => editor.api.isInline(n))) return false;\n\n          return !filter || filter([node, path]);\n        };\n\n        if (queryNode(blockEntry, queryNodeOptions)) {\n          editor.tf.removeNodes({ at: blockEntry[1] });\n          nextBlock = false;\n        }\n      }\n    }\n    if (nextBlock) {\n      const { at = editor.selection } = options;\n\n      if (at) {\n        const endPoint = editor.api.end(at);\n\n        const blockEntry = editor.api.above({\n          at: endPoint,\n          block: true,\n        });\n\n        if (blockEntry) {\n          options.at = PathApi.next(blockEntry[1]);\n        }\n      }\n    }\n\n    insertNodesBase(editor as any, nodes, options as any);\n  });\n};\n","import { Transforms } from 'slate';\n\nimport type { Editor, InsertTextOptions } from '../../interfaces';\n\nimport { getAt } from '../../utils';\n\nexport const insertText = (\n  editor: Editor,\n  text: string,\n  { marks = true, ...options }: InsertTextOptions = {}\n) => {\n  const at = getAt(editor, options.at);\n\n  // Case 1: Insert at options.at if specified, regardless of selection\n  if (at) {\n    Transforms.insertText(editor as any, text, { ...options, at });\n\n    return;\n  }\n  // Case 2: Default Slate behavior - only proceed if there's a selection\n  if (editor.selection) {\n    if (marks && editor.marks) {\n      // Case 2.1: Insert with marks if any\n      const node = { text, ...editor.marks };\n      editor.tf.insertNodes(node, {\n        voids: options.voids,\n      });\n      editor.marks = null;\n    } else {\n      // Case 2.2: Insert plain text\n      Transforms.insertText(editor as any, text, options as any);\n    }\n  }\n};\n","import { liftNodes as liftNodesBase } from 'slate';\n\nimport type { Editor, LiftNodesOptions, ValueOf } from '../../interfaces';\n\nimport { getQueryOptions } from '../../utils';\n\nexport const liftNodes = <E extends Editor>(\n  editor: E,\n  options?: LiftNodesOptions<ValueOf<E>>\n) => {\n  return liftNodesBase(editor as any, getQueryOptions(editor, options));\n};\n","import {\n  type Editor,\n  type MergeNodesOptions,\n  type TElement,\n  type TText,\n  type ValueOf,\n  ElementApi,\n  NodeApi,\n  PathApi,\n  RangeApi,\n  TextApi,\n} from '../../interfaces';\nimport { getQueryOptions } from '../../utils';\n\nexport const mergeNodes = <E extends Editor>(\n  editor: E,\n  options: MergeNodesOptions<ValueOf<E>, E> = {}\n): void => {\n  options = getQueryOptions(editor, options);\n\n  editor.tf.withoutNormalizing(() => {\n    let { at = editor.selection!, match } = options;\n    const {\n      hanging = false,\n      mergeNode,\n      mode = 'lowest',\n      removeEmptyAncestor,\n      voids = false,\n    } = options;\n\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (PathApi.isPath(at)) {\n        const [parent] = editor.api.parent(at)!;\n        match = (n) => parent.children.includes(n as any);\n      } else {\n        match = (n) => editor.api.isBlock(n);\n      }\n    }\n    if (!hanging && RangeApi.isRange(at)) {\n      at = editor.api.unhangRange(at);\n    }\n    if (RangeApi.isRange(at)) {\n      if (RangeApi.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end] = RangeApi.edges(at);\n        const pointRef = editor.api.pointRef(end);\n        editor.tf.delete({ at });\n        at = pointRef.unref()!;\n\n        if (options.at == null) {\n          editor.tf.select(at);\n        }\n      }\n    }\n\n    const _nodes = editor.api.nodes({ at, match, mode, voids });\n    const [current] = Array.from(_nodes);\n    const prev = editor.api.previous({ at, match, mode, voids });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    const newPath = PathApi.next(prevPath);\n    const commonPath = PathApi.common(path, prevPath);\n    const isPreviousSibling = PathApi.isSibling(path, prevPath);\n    const _levels = editor.api.levels({ at: path });\n    const levels = new Set(\n      Array.from(_levels, ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n    );\n\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    const emptyAncestor = editor.api.above({\n      at: path,\n      mode: 'highest',\n      match: (n) =>\n        levels.has(n) && ElementApi.isElement(n) && NodeApi.hasSingleChild(n),\n    });\n\n    const emptyRef = emptyAncestor && editor.api.pathRef(emptyAncestor[1]);\n    let properties;\n    let position;\n\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (TextApi.isText(node) && TextApi.isText(prevNode)) {\n      const { text, ...rest } = node;\n      position = prevNode.text.length;\n      properties = rest as Partial<TText>;\n    } else if (ElementApi.isElement(node) && ElementApi.isElement(prevNode)) {\n      const { children, ...rest } = node;\n      position = prevNode.children.length;\n      properties = rest as Partial<TElement>;\n    } else {\n      throw new TypeError(\n        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n          node\n        )} ${JSON.stringify(prevNode)}`\n      );\n    }\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (\n      !isPreviousSibling && // DIFF\n      !mergeNode\n    ) {\n      editor.tf.moveNodes({ at: path, to: newPath, voids });\n    }\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      // DIFF: start\n      if (removeEmptyAncestor) {\n        const emptyPath = emptyRef.current;\n        emptyPath && removeEmptyAncestor(editor as any, { at: emptyPath });\n      } else {\n        editor.tf.removeNodes({ at: emptyRef.current!, voids });\n      }\n      // DIFF: end\n    }\n    // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // DIFF: start\n    if (mergeNode) {\n      mergeNode(editor as any, { at: path, to: newPath });\n      // DIFF: end\n    } else if (\n      (ElementApi.isElement(prevNode) && editor.api.isEmpty(prevNode)) ||\n      (TextApi.isText(prevNode) && prevNode.text === '')\n    ) {\n      editor.tf.removeNodes({ at: prevPath, voids });\n    } else {\n      editor.tf.apply({\n        path: newPath,\n        position,\n        properties,\n        type: 'merge_node',\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n","import { moveNodes as moveNodesBase } from 'slate';\n\nimport {\n  type Editor,\n  type MoveNodesOptions,\n  type TElement,\n  type ValueOf,\n  NodeApi,\n} from '../../interfaces';\nimport { getQueryOptions } from '../../utils';\n\nexport const moveNodes = <E extends Editor>(\n  editor: E,\n  { children, fromIndex = 0, ...opt }: MoveNodesOptions<ValueOf<E>>\n) => {\n  const options = getQueryOptions(editor, opt);\n\n  let moved = false;\n\n  if (children) {\n    if (!options.at) return moved;\n\n    const entry = editor.api.node(options.at!);\n\n    if (!entry) return moved;\n\n    const [node, path] = entry;\n\n    if (!editor.api.isBlock(node)) return moved;\n\n    for (\n      let i = (node.children as TElement[]).length - 1;\n      i >= fromIndex;\n      i--\n    ) {\n      const childPath = [...path, i];\n      const childNode = NodeApi.get(editor, childPath);\n\n      if (\n        !options.match ||\n        (childNode && options.match(childNode, childPath))\n      ) {\n        moveNodesBase(editor as any, {\n          ...options,\n          at: childPath,\n        });\n        moved = true;\n      }\n    }\n\n    return moved;\n  }\n\n  return moveNodesBase(editor as any, options);\n};\n","import type { SelectionMoveOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { move } from 'slate';\n\nimport type { Editor } from '../../interfaces';\n\nexport const moveSelection = (\n  editor: Editor,\n  options?: SelectionMoveOptions\n) => {\n  move(editor as any, options);\n};\n","import { removeNodes as removeNodesBase } from 'slate';\n\nimport type { Editor, RemoveNodesOptions, ValueOf } from '../../interfaces';\n\nimport { NodeApi } from '../../interfaces';\nimport { getQueryOptions } from '../../utils';\n\nexport const removeNodes = <E extends Editor>(\n  editor: E,\n  { children, previousEmptyBlock, ...opt }: RemoveNodesOptions<ValueOf<E>> = {}\n) => {\n  const options = getQueryOptions(editor, opt);\n\n  editor.tf.withoutNormalizing(() => {\n    if (previousEmptyBlock) {\n      const entry = editor.api.block({ at: options.at });\n\n      if (!entry) return;\n\n      const prevEntry = editor.api.previous({\n        at: entry[1],\n        sibling: true,\n      });\n\n      if (!prevEntry) return;\n\n      const [prevNode, prevPath] = prevEntry;\n\n      if (editor.api.isEmpty(prevNode)) {\n        editor.tf.removeNodes({ at: prevPath });\n      }\n\n      return;\n    }\n    // Handle children option\n    if (children && options.at) {\n      for (const [, childPath] of NodeApi.children(editor, options.at, {\n        reverse: true,\n      })) {\n        editor.tf.removeNodes({ ...options, at: childPath });\n      }\n\n      return;\n    }\n\n    return removeNodesBase(editor as any, getQueryOptions(editor, options));\n  });\n};\n","import { setNodes as setNodesBase } from 'slate';\n\nimport type {\n  DescendantOf,\n  Editor,\n  Path,\n  SetNodesOptions,\n  TNode,\n  ValueOf,\n} from '../../interfaces';\nimport type { NodeProps } from '../../interfaces/node';\n\nimport { PathApi, RangeApi, TextApi } from '../../interfaces';\nimport { getAt, getQueryOptions } from '../../utils';\n\nexport const setNodes = <N extends DescendantOf<E>, E extends Editor = Editor>(\n  editor: E,\n  props: Partial<NodeProps<N>>,\n  { marks, ...options }: SetNodesOptions<ValueOf<E>> & {} = {}\n) => {\n  if (marks) {\n    let at = getAt(editor, options.at) ?? editor.selection;\n\n    if (!at) return;\n    if (PathApi.isPath(at)) {\n      at = editor.api.range(at)!;\n    }\n    if (!RangeApi.isRange(at)) return;\n\n    const match = (node: TNode, path: Path) => {\n      if (!TextApi.isText(node)) return false;\n\n      const parentEntry = editor.api.parent(path);\n\n      if (!parentEntry) return false;\n\n      const [parentNode] = parentEntry;\n\n      return (\n        !editor.api.isVoid(parentNode as any) ||\n        editor.api.markableVoid(parentNode as any)\n      );\n    };\n\n    const isExpandedRange = RangeApi.isExpanded(at);\n    let markAcceptingVoidSelected = false;\n\n    if (!isExpandedRange) {\n      const selectedEntry = editor.api.node(at);\n\n      if (!selectedEntry) return;\n\n      const [selectedNode, selectedPath] = selectedEntry;\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const parentEntry = editor.api.parent(selectedPath);\n\n        if (!parentEntry) return;\n\n        const [parentNode] = parentEntry;\n        markAcceptingVoidSelected =\n          parentNode && editor.api.markableVoid(parentNode as any);\n      }\n    }\n    if (isExpandedRange || markAcceptingVoidSelected) {\n      return setNodesBase(\n        editor as any,\n        props as any,\n        getQueryOptions(editor, {\n          ...options,\n          at,\n          match,\n          split: true,\n          voids: true,\n        })\n      );\n    }\n  }\n\n  return setNodesBase(\n    editor as any,\n    props as any,\n    getQueryOptions(editor, options)\n  );\n};\n","import type { SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { setPoint as setPointBase } from 'slate';\n\nimport type { Editor } from '../../interfaces';\nimport type { Point } from '../../interfaces/point';\n\nexport const setPoint = (\n  editor: Editor,\n  props: Partial<Point>,\n  options?: SelectionSetPointOptions\n) => {\n  setPointBase(editor as any, props, options);\n};\n","import { setSelection as setSelectionBase } from 'slate';\n\nimport type { Editor, TRange } from '../../interfaces';\n\nexport const setSelection = (editor: Editor, props: Partial<TRange>) => {\n  setSelectionBase(editor as any, props);\n};\n","import { splitNodes as splitNodesBase } from 'slate';\n\nimport type { Editor, SplitNodesOptions, ValueOf } from '../../interfaces';\n\nimport { getQueryOptions } from '../../utils';\n\nexport const splitNodes = <E extends Editor>(\n  editor: E,\n  options?: SplitNodesOptions<ValueOf<E>>\n) => {\n  return splitNodesBase(editor as any, getQueryOptions(editor, options));\n};\n","import { unsetNodes as unsetNodesBase } from 'slate';\n\nimport type {\n  DescendantOf,\n  Editor,\n  UnsetNodesOptions,\n  ValueOf,\n} from '../../interfaces';\nimport type { NodeProps } from '../../interfaces/node';\n\nimport { getQueryOptions } from '../../utils';\n\nexport const unsetNodes = <\n  N extends DescendantOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  props: (keyof NodeProps<N>)[] | keyof NodeProps<N>,\n  options?: UnsetNodesOptions<ValueOf<E>>\n) => {\n  return unsetNodesBase(\n    editor as any,\n    props as any,\n    getQueryOptions(editor, options)\n  );\n};\n","import { unwrapNodes as unwrapNodesBase } from 'slate';\n\nimport type { Editor, UnwrapNodesOptions, ValueOf } from '../../interfaces';\n\nimport { getQueryOptions } from '../../utils/match';\n\nexport const unwrapNodes = <E extends Editor>(\n  editor: E,\n  options?: UnwrapNodesOptions<ValueOf<E>>\n) => {\n  unwrapNodesBase(editor as any, getQueryOptions(editor, options));\n};\n","import { wrapNodes as wrapNodesBase } from 'slate';\n\nimport type {\n  Editor,\n  ElementOf,\n  TElement,\n  ValueOf,\n  WrapNodesOptions,\n} from '../../interfaces';\n\nimport { NodeApi, PathApi } from '../../interfaces';\nimport { getQueryOptions } from '../../utils';\n\nexport const wrapNodes = <N extends ElementOf<E>, E extends Editor = Editor>(\n  editor: E,\n  element: N,\n  { children, ...opt }: WrapNodesOptions<ValueOf<E>> = {}\n) => {\n  const options = getQueryOptions(editor, opt);\n\n  if (options.at) {\n    options.at = editor.api.unhangRange(options.at, options);\n  }\n  // Handle wrapping node children\n  if (children) {\n    const path = editor.api.path(options.at);\n\n    if (!path) return;\n\n    const node = NodeApi.get<TElement>(editor, path);\n\n    if (!node?.children) return;\n\n    editor.tf.withoutNormalizing(() => {\n      const firstChildPath = PathApi.firstChild(path);\n\n      // Wrap first child\n      wrapNodesBase(editor as any, element as any, {\n        ...options,\n        at: firstChildPath,\n      });\n\n      // Move remaining children if any\n      if (node.children.length > 1) {\n        editor.tf.moveNodes({\n          at: path,\n          children: true,\n          fromIndex: 1,\n          to: PathApi.child(firstChildPath, 1),\n        });\n      }\n    });\n\n    return;\n  }\n\n  // Regular wrap nodes behavior\n  wrapNodesBase(editor as any, element as any, options as any);\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport { isPlainObject } from 'is-plain-object';\n\nimport {\n  type Editor,\n  type Operation,\n  type TRange,\n  OperationApi,\n} from '../interfaces/index';\n\n/** Weakmaps for attaching state to the editor. */\n\nconst SAVING = new WeakMap<Editor, boolean | undefined>();\n\nconst MERGING = new WeakMap<Editor, boolean | undefined>();\n\nconst SPLITTING_ONCE = new WeakMap<Editor, boolean | undefined>();\n\n/** `HistoryApi` contains helpers for history-enabled editors. */\nexport const HistoryApi = {\n  /** Check if a value is a `History` object. */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 ||\n        OperationApi.isOperationList(value.redos[0].operations)) &&\n      (value.undos.length === 0 ||\n        OperationApi.isOperationList(value.undos[0].operations))\n    );\n  },\n\n  /** Get the merge flag's current value. */\n  isMerging(editor: Editor): boolean | undefined {\n    return MERGING.get(editor);\n  },\n\n  /** Get the splitting once flag's current value. */\n  isSaving(editor: Editor): boolean | undefined {\n    return SAVING.get(editor);\n  },\n\n  isSplittingOnce(editor: Editor): boolean | undefined {\n    return SPLITTING_ONCE.get(editor);\n  },\n\n  /** Get the saving flag's current value. */\n  redo(editor: Editor): void {\n    editor.redo();\n  },\n\n  /** Redo to the previous saved state. */\n  setSplittingOnce(editor: Editor, value: boolean | undefined): void {\n    SPLITTING_ONCE.set(editor, value);\n  },\n\n  /** Undo to the previous saved state. */\n  undo(editor: Editor): void {\n    editor.undo();\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging(editor: Editor, fn: () => void): void {\n    const prev = editor.api.isMerging();\n    MERGING.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the\n   * first operation starts a new batch in the history. Subsequent operations\n   * will be merged as usual.\n   */\n  withNewBatch(editor: Editor, fn: () => void): void {\n    const prev = editor.api.isMerging();\n    MERGING.set(editor, true);\n    SPLITTING_ONCE.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n    SPLITTING_ONCE.delete(editor);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n  withoutMerging(editor: Editor, fn: () => void): void {\n    const prev = editor.api.isMerging();\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n  withoutSaving(editor: Editor, fn: () => void): void {\n    const prev = editor.api.isSaving();\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  },\n};\n\nexport interface History {\n  /** Redos of the editor. */\n  redos: Batch[];\n\n  /** Undos of the editor. */\n  undos: Batch[];\n}\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\ninterface Batch {\n  operations: Operation[];\n  selectionBefore: TRange | null;\n}\n","export { withDOM } from 'slate-dom';\n\nexport { TRIPLE_CLICK } from 'slate-dom';\n\nexport {\n  type StringDiff,\n  type TextDiff,\n  applyStringDiff,\n  mergeStringDiffs,\n  normalizePoint,\n  normalizeRange,\n  normalizeStringDiff,\n  targetRange,\n  verifyDiffState,\n} from 'slate-dom';\n\nexport {\n  type DOMElement,\n  type DOMNode,\n  type DOMPoint,\n  type DOMRange,\n  type DOMSelection,\n  type DOMStaticRange,\n  type DOMText,\n  getActiveElement,\n  getDefaultView,\n  getSelection,\n  hasShadowRoot,\n  isAfter,\n  isBefore,\n  isDOMElement,\n  isDOMNode,\n  isDOMSelection,\n  isPlainTextOnlyPaste,\n  isTrackedMutation,\n  normalizeDOMPoint,\n} from 'slate-dom';\n\nexport {\n  CAN_USE_DOM,\n  HAS_BEFORE_INPUT_SUPPORT,\n  IS_ANDROID,\n  IS_CHROME,\n  IS_FIREFOX,\n  IS_FIREFOX_LEGACY,\n  IS_IOS,\n  IS_UC_MOBILE,\n  IS_WEBKIT,\n  IS_WECHATBROWSER,\n} from 'slate-dom';\n\nexport { isElementDecorationsEqual, isTextDecorationsEqual } from 'slate-dom';\n","import {\n  type Editor,\n  type LegacyEditorMethods,\n  type Operation,\n  OperationApi,\n  PathApi,\n} from '../interfaces/index';\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n */\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as Editor & LegacyEditorMethods;\n  const { apply } = e;\n  e.history = { redos: [], undos: [] };\n\n  e.redo = () => {\n    const { history } = e;\n    const { redos } = history;\n\n    if (redos.length > 0) {\n      const batch = redos.at(-1)!;\n\n      if (batch.selectionBefore) {\n        e.tf.setSelection(batch.selectionBefore);\n      }\n\n      e.tf.withoutSaving(() => {\n        e.tf.withoutNormalizing(() => {\n          for (const op of batch.operations) {\n            e.apply(op);\n          }\n        });\n      });\n\n      history.redos.pop();\n      e.writeHistory('undos', batch);\n    }\n  };\n\n  e.undo = () => {\n    const { history } = e;\n    const { undos } = history;\n\n    if (undos.length > 0) {\n      const batch = undos.at(-1)!;\n\n      e.tf.withoutSaving(() => {\n        e.tf.withoutNormalizing(() => {\n          const inverseOps = batch.operations\n            .map(OperationApi.inverse)\n            .reverse();\n\n          for (const op of inverseOps) {\n            e.apply(op);\n          }\n\n          if (batch.selectionBefore) {\n            e.tf.setSelection(batch.selectionBefore);\n          }\n        });\n      });\n\n      e.writeHistory('redos', batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = (op: Operation) => {\n    const { history, operations } = e;\n    const { undos } = history;\n    const lastBatch = undos.at(-1);\n    const lastOp = lastBatch?.operations.at(-1);\n    let save = e.api.isSaving();\n    let merge = e.api.isMerging();\n\n    if (save == null) {\n      save = shouldSave(op, lastOp);\n    }\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length > 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n      if (e.api.isSplittingOnce()) {\n        merge = false;\n        e.tf.setSplittingOnce(undefined);\n      }\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        const batch = {\n          operations: [op],\n          selectionBefore: e.selection,\n        };\n        e.writeHistory('undos', batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      history.redos = [];\n    }\n\n    apply(op);\n  };\n\n  e.writeHistory = (stack: 'redos' | 'undos', batch: any) => {\n    e.history[stack].push(batch);\n  };\n\n  return e as T;\n};\n\n/** Check whether to merge an operation into the previous operation. */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    PathApi.equals(op.path, prev.path)\n  ) {\n    return true;\n  }\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    PathApi.equals(op.path, prev.path)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/** Check whether an operation needs to be saved to the history. */\n\nconst shouldSave = (op: Operation, _: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n"],"mappings":"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","names":["import_utils","import_slate","SlateElement","import_slate","import_slate","SlatePath","path","last","path","SlatePointRef","SlateRangeRef","import_slate","import_slate","import_slate","path","parent","import_slate","SlateText","SlateNode","node","SlateLocation","SlateSpan","import_slate","SlateOperation","import_slate","import_slate","SlateRange","range","SlatePoint","focus","point","import_slate_dom","import_slate_dom","import_slate_dom","import_slate_dom","node","import_slate_dom","node","n","import_slate_dom","at","import_slate_dom","import_slate_dom","import_slate_dom","import_slate_dom","range","import_slate_dom","import_slate_dom","import_slate_dom","import_slate_dom","import_slate_dom","import_slate_dom","import_slate_dom","node","import_slate_dom","point","import_slate_dom","range","import_slate_dom","import_slate_dom","import_slate_dom","start","end","above","e","import_slate","import_slate","import_slate","point","import_slate","isPlainObject","import_slate","import_slate","import_slate","beforeBase","castArray","point","map","import_slate","import_slate","import_slate","isBlockBase","castArray","path","block","n","match","node","match","first","last","node","path","import_slate","withoutNormalizingBase","import_slate","focus","next","previous","at","path","point","selectBase","e","EditorInterface","start","end","n","after","node","path","pathRefs","point","pathRef","import_castArray","castArray","castArray","node","path","levels","first","last","n","node","path","marks","range","block","blocks","end","start","after","point","node","nodes","nodes","node","isElement","el","nodeType","canOverflow","overflow","skipOverflowHiddenElements","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","style","getComputedStyle","overflowY","overflowX","frame","ownerDocument","defaultView","frameElement","e","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","getParentElement","element","parent","parentElement","getRootNode","host","compute","target","options","_a","_b","_c","_d","document","scrollMode","block","inline","boundary","checkBoundary","node","TypeError","scrollingElement","documentElement","frames","cursor","push","body","viewportWidth","window","visualViewport","width","innerWidth","viewportHeight","height","innerHeight","scrollX","scrollY","targetHeight","targetWidth","top","targetTop","right","targetRight","bottom","targetBottom","left","targetLeft","getBoundingClientRect","marginTop","marginRight","marginBottom","marginLeft","computedStyle","parseFloat","scrollMarginTop","scrollMarginRight","scrollMarginBottom","scrollMarginLeft","targetBlock","targetInline","computations","index","length","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","scaleX","scaleY","Math","max","scrollLeft","scrollTop","min","getOptions","options","block","inline","Object","keys","length","scrollIntoView","target","isConnected","element","currentElement","parentNode","document","ShadowRoot","host","margins","computedStyle","window","getComputedStyle","top","parseFloat","scrollMarginTop","right","scrollMarginRight","bottom","scrollMarginBottom","left","scrollMarginLeft","behavior","compute","el","adjustedTop","adjustedLeft","scroll","path","e","import_slate","aboveBase","import_slate","addMarkBase","import_slate","range","import_slate","deleteBackwardBase","import_slate","deleteForwardBase","import_slate","deleteFragmentBase","import_slate","nodeBase","import_slate","pathBase","import_slate","import_slate","import_slate","import_slate","nodes","node","getFragmentBase","import_slate","import_slate","import_slate","import_slate","import_slate","import_slate","import_slate","import_slate","hasBlocksBase","import_slate","hasInlinesBase","import_slate","hasTextsBase","import_slate","insertBreakBase","node","import_slate","point","import_slate","import_slate","import_slate","isEmptyBase","point","node","block","nodes","import_slate","point","import_slate","point","import_slate","node","path","lastBase","match","start","path","n","parent","next","import_slate","import_slate","parentBase","match","start","n","parent","previous","o","path","block","import_slate","path","focus","rangeBase","import_slate","import_slate","range","start","end","unhangRangeBase","import_castArray","marks","castArray","block","nodes","node","import_castArray","match","node","path","castArray","marks","nodes","path","import_castArray","castArray","import_slate","import_slate","deleteTextBase","import_slate","deselectBase","import_slate","fragment","insertFragmentBase","import_slate","nodes","node","path","n","insertNodesBase","import_slate","marks","node","import_slate","liftNodesBase","match","parent","n","end","pointRef","node","path","levels","import_slate","node","path","moveNodesBase","import_slate","import_slate","removeNodesBase","import_slate","marks","match","node","path","setNodesBase","import_slate","setPointBase","import_slate","setSelectionBase","import_slate","splitNodesBase","import_slate","unsetNodesBase","import_slate","unwrapNodesBase","import_slate","path","node","wrapNodesBase","createSlateEditor","import_slate_dom","e","apply"]}