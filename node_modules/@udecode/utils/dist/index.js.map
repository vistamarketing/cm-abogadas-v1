{"version":3,"sources":["../src/index.ts","../src/environment.ts","../src/escapeRegexp.ts","../src/findHtmlParentElement.ts","../src/getHandler.ts","../src/hexToBase64.ts","../src/isUrl.ts","../src/mergeProps.ts","../src/sanitizeUrl.ts","../src/type-utils.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './environment';\nexport * from './escapeRegexp';\nexport * from './findHtmlParentElement';\nexport * from './getHandler';\nexport * from './hexToBase64';\nexport * from './isUrl';\nexport * from './mergeProps';\nexport * from './sanitizeUrl';\nexport * from './type-utils';\nexport * from './types/index';\n","export const IS_APPLE =\n  typeof navigator !== 'undefined' && navigator.userAgent.includes('Mac OS X');\n","export const escapeRegExp = (text: string) => {\n  return text.replaceAll(/[#$()*+,.?[\\\\\\]^s{|}-]/g, String.raw`\\$&`);\n};\n","export const findHtmlParentElement = (\n  el: HTMLElement | null,\n  nodeName: string\n): HTMLElement | null => {\n  if (!el || el.nodeName === nodeName) {\n    return el;\n  }\n\n  return findHtmlParentElement(el.parentElement, nodeName);\n};\n","/** Call a handler if defined */\nexport const getHandler =\n  <T extends (...args: any) => any>(cb?: T, ...args: Parameters<T>) =>\n  () => {\n    cb?.(...(args as any));\n  };\n","export const hexToBase64 = (hex: string): string => {\n  const hexPairs = hex.match(/\\w{2}/g) || [];\n  const binary = hexPairs.map((hexPair) =>\n    String.fromCodePoint(Number.parseInt(hexPair, 16))\n  );\n\n  return btoa(binary.join(''));\n};\n","/**\n * RegExps. A URL must match #1 and then at least one of #2/#3. Use two levels\n * of REs to avoid REDOS.\n */\n\nconst protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nconst emailLintRE = /mailto:([^?\\\\]+)/;\n\nconst localhostDomainRE = /^localhost[\\d:?]*(?:[^\\d:?]\\S*)?$/;\nconst nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\n\n/** Loosely validate a URL `string`. */\nexport const isUrl = (string: any) => {\n  if (typeof string !== 'string') {\n    return false;\n  }\n\n  const generalMatch = protocolAndDomainRE.exec(string);\n  const emailLinkMatch = emailLintRE.exec(string);\n\n  const match = generalMatch || emailLinkMatch;\n\n  if (!match) {\n    return false;\n  }\n\n  const everythingAfterProtocol = match[1];\n\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n\n  try {\n    new URL(string);\n  } catch {\n    return false;\n  }\n\n  return (\n    localhostDomainRE.test(everythingAfterProtocol) ||\n    nonLocalhostDomainRE.test(everythingAfterProtocol)\n  );\n};\n","/** Merge props by composing handlers. */\nexport const mergeProps = <T>(\n  props?: T,\n  overrideProps?: T,\n  {\n    handlerKeys,\n    handlerQuery = (key) => key.startsWith('on'),\n  }: {\n    /** The keys of the handlers to merge. */\n    handlerKeys?: string[];\n    /**\n     * A function that returns true if it's a handler to merge.\n     *\n     * Default: keys having `on` prefix.\n     */\n    handlerQuery?: ((key: string) => boolean) | null;\n  } = {}\n): T => {\n  const map = new Map<string, ((...args: unknown[]) => void)[]>();\n\n  const acc: any = {};\n\n  const mapProps = (_props?: T) => {\n    if (!_props) return;\n\n    Object.entries(_props).forEach(([key, value]) => {\n      if (\n        (!handlerKeys || handlerKeys.includes(key)) &&\n        (!handlerQuery || handlerQuery(key)) &&\n        typeof value === 'function'\n      ) {\n        if (!map.has(key)) {\n          map.set(key, []);\n        }\n\n        map.get(key)?.push(value as any);\n\n        acc[key] = (...args: unknown[]) => {\n          map.get(key)?.forEach((fn) => fn(...args));\n        };\n      } else {\n        acc[key] = value;\n      }\n    });\n  };\n\n  mapProps(props);\n  mapProps(overrideProps);\n\n  return acc;\n};\n","export interface SanitizeUrlOptions {\n  allowedSchemes?: string[];\n  permitInvalid?: boolean;\n}\n\nexport const sanitizeUrl = (\n  url: string | undefined,\n  { allowedSchemes, permitInvalid = false }: SanitizeUrlOptions\n): string | null => {\n  if (!url) return null;\n\n  // Allow internal links starting with / or #\n  if (url.startsWith('/') || url.startsWith('#')) {\n    return url;\n  }\n\n  let parsedUrl: URL | null = null;\n\n  try {\n    parsedUrl = new URL(url);\n  } catch {\n    return permitInvalid ? url : null;\n  }\n\n  if (\n    allowedSchemes &&\n    !allowedSchemes.includes(parsedUrl.protocol.slice(0, -1))\n  ) {\n    return null;\n  }\n\n  return parsedUrl.href;\n};\n","/** @returns Whether the provided parameter is undefined. */\nexport const isUndefined = (obj: any): obj is undefined => obj === undefined;\n\nexport const isNull = (obj: any): obj is null => obj === null;\n\n/** @returns Whether the provided parameter is undefined or null. */\nexport const isUndefinedOrNull = (obj: any): obj is null | undefined =>\n  isUndefined(obj) || isNull(obj);\n\n/** @returns Whether the provided parameter is defined. */\nexport const isDefined = <T>(arg: T | null | undefined): arg is T =>\n  !isUndefinedOrNull(arg);\n\nexport function bindFirst<T, Args extends any[], R>(\n  fn: (first: T, ...args: Args) => R,\n  firstArg: T\n): (...args: Args) => R {\n  return (...args) => fn(firstArg, ...args);\n}\n"],"mappings":"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","names":[]}