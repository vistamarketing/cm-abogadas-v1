{"version":3,"sources":["../src/index.ts","../src/lib/BaseIndentListPlugin.ts","../src/lib/renderIndentListBelowNodes.tsx","../src/lib/types.ts","../src/lib/withIndentList.ts","../src/lib/normalizers/normalizeIndentListNotIndented.ts","../src/lib/normalizers/normalizeIndentListStart.ts","../src/lib/queries/getPreviousIndentList.ts","../src/lib/queries/getSiblingIndentList.ts","../src/lib/normalizers/shouldMergeNodesRemovePrevNodeIndentList.ts","../src/lib/normalizers/withDeleteBackwardIndentList.ts","../src/lib/transforms/indentList.ts","../src/lib/transforms/outdentList.ts","../src/lib/transforms/setIndentListNode.ts","../src/lib/transforms/setIndentListNodes.ts","../src/lib/transforms/setIndentListSiblingNodes.ts","../src/lib/queries/getNextIndentList.ts","../src/lib/queries/getIndentListSiblings.ts","../src/lib/transforms/toggleIndentList.ts","../src/lib/queries/areEqListStyleType.ts","../src/lib/queries/getIndentListAbove.ts","../src/lib/queries/getSiblingListStyleType.ts","../src/lib/queries/someIndentList.ts","../src/lib/queries/someIndentTodo.ts","../src/lib/transforms/toggleIndentListSet.ts","../src/lib/transforms/toggleIndentListUnset.ts","../src/lib/transforms/toggleIndentListByPath.ts","../src/lib/normalizers/withInsertBreakIndentList.ts","../src/lib/withNormalizeIndentList.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './lib/index';\n","import {\n  type PluginConfig,\n  type SlateRenderElementProps,\n  type TElement,\n  BaseParagraphPlugin,\n  createTSlatePlugin,\n  HtmlPlugin,\n  isHtmlBlockElement,\n  postCleanHtml,\n  traverseHtmlElements,\n} from '@udecode/plate';\n\nimport type { GetSiblingIndentListOptions } from './queries/getSiblingIndentList';\nimport type { ListStyleType } from './types';\n\nimport { renderIndentListBelowNodes } from './renderIndentListBelowNodes';\nimport { withIndentList } from './withIndentList';\n\n/**\n * All list items are normalized to have a listStart prop indicating their\n * position in the list (unless listStart would be 1, in which case it is\n * omitted).\n *\n * ListRestart causes listStart to restart from the given number, regardless of\n * any previous listStart.\n *\n * ListRestartPolite acts like listRestart, except it only takes effect for list\n * items at the start of a list. When not at the start of a list, this prop is\n * ignored, although it is not removed and may take effect in the future.\n */\n\nexport const INDENT_LIST_KEYS = {\n  checked: 'checked',\n  listRestart: 'listRestart',\n  listRestartPolite: 'listRestartPolite',\n  listStart: 'listStart',\n  todo: 'todo',\n} as const;\n\nexport type BaseIndentListConfig = PluginConfig<\n  'listStyleType',\n  {\n    getSiblingIndentListOptions?: GetSiblingIndentListOptions<TElement>;\n    listStyleTypes?: Record<\n      string,\n      {\n        type: string;\n        isOrdered?: boolean;\n        liComponent?: React.FC<SlateRenderElementProps>;\n        markerComponent?: React.FC<Omit<SlateRenderElementProps, 'children'>>;\n      }\n    >;\n    /** Map html element to list style type. */\n    getListStyleType?: (element: HTMLElement) => ListStyleType;\n  }\n>;\n\nexport const BaseIndentListPlugin = createTSlatePlugin<BaseIndentListConfig>({\n  key: 'listStyleType',\n  inject: {\n    plugins: {\n      [HtmlPlugin.key]: {\n        parser: {\n          transformData: ({ data }) => {\n            const document = new DOMParser().parseFromString(data, 'text/html');\n            const { body } = document;\n\n            traverseHtmlElements(body, (element) => {\n              if (element.tagName === 'LI') {\n                const { childNodes } = element;\n\n                // replace li block children (e.g. p) by their children\n                const liChildren: Node[] = [];\n                childNodes.forEach((child) => {\n                  if (isHtmlBlockElement(child as Element)) {\n                    liChildren.push(...child.childNodes);\n                  } else {\n                    liChildren.push(child);\n                  }\n                });\n\n                element.replaceChildren(...liChildren);\n\n                // TODO: recursive check on ul parents for indent\n\n                return false;\n              }\n\n              return true;\n            });\n\n            return postCleanHtml(body.innerHTML);\n          },\n        },\n      },\n    },\n  },\n  options: {\n    getListStyleType: (element) => element.style.listStyleType as ListStyleType,\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        isElement: true,\n        rules: [\n          {\n            validNodeName: 'LI',\n          },\n        ],\n        parse: ({ editor, element, getOptions }) => {\n          return {\n            // gdoc uses aria-level attribute\n            indent: Number(element.getAttribute('aria-level')),\n            listStyleType: getOptions().getListStyleType?.(element),\n            type: editor.getType(BaseParagraphPlugin),\n          };\n        },\n      },\n    },\n  },\n  render: {\n    belowNodes: renderIndentListBelowNodes,\n  },\n}).overrideEditor(withIndentList);\n","import React from 'react';\n\nimport type {\n  RenderStaticNodeWrapper,\n  RenderStaticNodeWrapperFunction,\n  RenderStaticNodeWrapperProps,\n} from '@udecode/plate';\n\nimport { clsx } from 'clsx';\n\nimport {\n  type BaseIndentListConfig,\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../lib';\nimport { ULIST_STYLE_TYPES } from '../lib/types';\n\nexport const renderIndentListBelowNodes: RenderStaticNodeWrapper = (\n  injectProps: RenderStaticNodeWrapperProps<BaseIndentListConfig>\n): RenderStaticNodeWrapperFunction => {\n  const { element } = injectProps;\n\n  const listStyleType = element[BaseIndentListPlugin.key] as string;\n  const listStart = element[INDENT_LIST_KEYS.listStart] as number;\n\n  if (listStyleType) {\n    let className = clsx(`slate-${BaseIndentListPlugin.key}-${listStyleType}`);\n    const style: React.CSSProperties = {\n      listStyleType,\n      margin: 0,\n      padding: 0,\n      position: 'relative',\n    };\n\n    return ({ children, ...props }) => {\n      const { editor } = props;\n\n      const { listStyleTypes = {} } = editor.getOptions(BaseIndentListPlugin);\n\n      let listOptions = listStyleTypes[listStyleType];\n\n      let isOrdered = true;\n\n      if (listOptions) {\n        isOrdered = !!listOptions.isOrdered;\n      } else {\n        if (ULIST_STYLE_TYPES.includes(listStyleType as any)) {\n          isOrdered = false;\n        }\n\n        listOptions = {} as any;\n      }\n\n      className = isOrdered\n        ? clsx(className, 'slate-ol')\n        : clsx(className, 'slate-ul');\n\n      const List = isOrdered ? 'ol' : 'ul';\n\n      const { liComponent: Li, markerComponent: Marker = () => null } =\n        listOptions;\n\n      return (\n        <List className={className} style={style} start={listStart}>\n          <Marker {...props} />\n          {/* FIX: cursor position issue */}\n          {Li ? <Li {...props}>{children}</Li> : <li>{children}</li>}\n        </List>\n      );\n    };\n  }\n};\n","export enum ListStyleType {\n  ArabicIndic = 'arabic-indic',\n  Armenian = 'armenian',\n  Bengali = 'bengali',\n  Cambodian = 'cambodian',\n  Circle = 'circle',\n  CjkDecimal = 'cjk-decimal',\n  CjkEarthlyBranch = 'cjk-earthly-branch',\n  CjkHeavenlyStem = 'cjk-heavenly-stem',\n  Decimal = 'decimal',\n  DecimalLeadingZero = 'decimal-leading-zero',\n  Devanagari = 'devanagari',\n  Disc = 'disc',\n  DisclosureClosed = 'disclosure-closed',\n  DisclosureOpen = 'disclosure-open',\n  EthiopicNumeric = 'ethiopic-numeric',\n  Georgian = 'georgian',\n  Gujarati = 'gujarati',\n  Gurmukhi = 'gurmukhi',\n  Hebrew = 'hebrew',\n  Hiragana = 'hiragana',\n  HiraganaIroha = 'hiragana-iroha',\n  Inherit = 'inherit',\n  Initial = 'initial',\n  JapaneseFormal = 'japanese-formal',\n  JapaneseInformal = 'japanese-informal',\n  Kannada = 'kannada',\n  Katakana = 'katakana',\n  KatakanaIroha = 'katakana-iroha',\n  Khmer = 'khmer',\n  KoreanHangulFormal = 'korean-hangul-formal',\n  KoreanHanjaFormal = 'korean-hanja-formal',\n  KoreanHanjaInformal = 'korean-hanja-informal',\n  Lao = 'lao',\n  LowerAlpha = 'lower-alpha',\n  LowerArmenian = 'lower-armenian',\n  LowerGreek = 'lower-greek',\n  LowerLatin = 'lower-latin',\n  LowerRoman = 'lower-roman',\n  Malayalam = 'malayalam',\n  Mongolian = 'mongolian',\n  Myanmar = 'myanmar',\n  None = 'none',\n  Oriya = 'oriya',\n  Persian = 'persian',\n  SimpChineseFormal = 'simp-chinese-formal',\n  SimpChineseInformal = 'simp-chinese-informal',\n  Square = 'square',\n  Tamil = 'tamil',\n  Telugu = 'telugu',\n  Thai = 'thai',\n  Tibetan = 'tibetan',\n  TradChineseFormal = 'trad-chinese-formal',\n  TradChineseInformal = 'trad-chinese-informal',\n  UpperAlpha = 'upper-alpha',\n  UpperArmenian = 'upper-armenian',\n  UpperLatin = 'upper-latin',\n  UpperRoman = 'upper-roman',\n}\n\nexport const ULIST_STYLE_TYPES = [\n  ListStyleType.Disc,\n  ListStyleType.Circle,\n  ListStyleType.Square,\n  ListStyleType.DisclosureOpen,\n  ListStyleType.DisclosureClosed,\n] as const;\n","import {\n  type NodeEntry,\n  type OverrideEditor,\n  type Path,\n  type TElement,\n  type TNode,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type BaseIndentListConfig,\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from './BaseIndentListPlugin';\nimport {\n  withDeleteBackwardIndentList,\n  withInsertBreakIndentList,\n} from './normalizers';\nimport { normalizeIndentListStart } from './normalizers/normalizeIndentListStart';\nimport { getNextIndentList } from './queries/getNextIndentList';\nimport { getPreviousIndentList } from './queries/getPreviousIndentList';\nimport { ListStyleType } from './types';\nimport { withNormalizeIndentList } from './withNormalizeIndentList';\n\nexport const withIndentList: OverrideEditor<BaseIndentListConfig> = (ctx) => {\n  const {\n    editor,\n    getOptions,\n    tf: { apply },\n  } = ctx;\n\n  return {\n    transforms: {\n      ...withNormalizeIndentList(ctx).transforms,\n      ...withDeleteBackwardIndentList(ctx).transforms,\n      ...withInsertBreakIndentList(ctx).transforms,\n      apply(operation) {\n        const { getSiblingIndentListOptions } = getOptions();\n\n        /**\n         * If there is a previous indent list, the inserted indent list style\n         * type should be the same. Only for lower-roman and upper-roman as it\n         * overlaps with lower-alpha and upper-alpha.\n         */\n        if (operation.type === 'insert_node') {\n          const listStyleType = operation.node[BaseIndentListPlugin.key];\n\n          if (\n            listStyleType &&\n            ['lower-roman', 'upper-roman'].includes(\n              listStyleType as ListStyleType\n            )\n          ) {\n            const prevNodeEntry = getPreviousIndentList<TElement>(\n              editor,\n              [operation.node as TElement, operation.path],\n              {\n                breakOnEqIndentNeqListStyleType: false,\n                eqIndent: false,\n                ...getSiblingIndentListOptions,\n              }\n            );\n\n            if (prevNodeEntry) {\n              const prevListStyleType =\n                prevNodeEntry[0][BaseIndentListPlugin.key];\n\n              if (\n                prevListStyleType === ListStyleType.LowerAlpha &&\n                listStyleType === ListStyleType.LowerRoman\n              ) {\n                operation.node[BaseIndentListPlugin.key] =\n                  ListStyleType.LowerAlpha;\n              } else if (\n                prevListStyleType === ListStyleType.UpperAlpha &&\n                listStyleType === ListStyleType.UpperRoman\n              ) {\n                operation.node[BaseIndentListPlugin.key] =\n                  ListStyleType.UpperAlpha;\n              }\n            }\n          }\n        }\n\n        /**\n         * When inserting a line break, remove listRestart and listRestartPolite\n         * from the new list item.\n         */\n        if (\n          operation.type === 'split_node' &&\n          (operation.properties as any)[BaseIndentListPlugin.key]\n        ) {\n          (operation.properties as any)[INDENT_LIST_KEYS.listRestart] =\n            undefined;\n          (operation.properties as any)[INDENT_LIST_KEYS.listRestartPolite] =\n            undefined;\n        }\n\n        apply(operation);\n\n        // Normalize all list items affected by the operation\n        const affectedPaths: Path[] = [];\n\n        switch (operation.type) {\n          case 'insert_node':\n          case 'remove_node':\n          case 'set_node': {\n            affectedPaths.push(operation.path);\n            break;\n          }\n          case 'merge_node': {\n            affectedPaths.push(PathApi.previous(operation.path)!);\n            break;\n          }\n          case 'move_node': {\n            affectedPaths.push(operation.path, operation.newPath);\n            break;\n          }\n          case 'split_node': {\n            affectedPaths.push(operation.path, PathApi.next(operation.path));\n            break;\n          }\n        }\n\n        const isIndentListItem = (node: TNode) =>\n          BaseIndentListPlugin.key in node;\n\n        affectedPaths.forEach((affectedPath) => {\n          let entry = editor.api.node(affectedPath);\n          if (!entry) return;\n\n          /**\n           * Even if the affected node isn't a list item, the subsequent node\n           * might be, in which case we want to normalize that node instead.\n           */\n          if (!isIndentListItem(entry[0])) {\n            entry = editor.api.node(PathApi.next(affectedPath));\n          }\n\n          // Normalize the entire list from the affected node onwards\n          while (entry && isIndentListItem(entry[0])) {\n            const normalized = normalizeIndentListStart<TElement>(\n              editor,\n              entry as NodeEntry<TElement>,\n              getSiblingIndentListOptions\n            );\n\n            /**\n             * Break early since the subsequent list items will already have\n             * been normalized by the `apply` that modified the current node.\n             */\n            if (normalized) break;\n\n            entry = getNextIndentList<TElement>(\n              editor,\n              entry as NodeEntry<TElement>,\n              {\n                ...getSiblingIndentListOptions,\n                breakOnEqIndentNeqListStyleType: false,\n                breakOnLowerIndent: false,\n                eqIndent: false,\n              }\n            );\n          }\n        });\n      },\n    },\n  };\n};\n","import { type Editor, type NodeEntry, isDefined } from '@udecode/plate';\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\n/** Unset IndentListPlugin.key, listStart if BaseIndentPlugin.key is not defined. */\nexport const normalizeIndentListNotIndented = (\n  editor: Editor,\n  [node, path]: NodeEntry\n) => {\n  if (\n    !isDefined(node[BaseIndentPlugin.key]) &&\n    (node[BaseIndentListPlugin.key] || node[INDENT_LIST_KEYS.listStart])\n  ) {\n    editor.tf.unsetNodes(\n      [BaseIndentListPlugin.key, INDENT_LIST_KEYS.listStart],\n      {\n        at: path,\n      }\n    );\n\n    return true;\n  }\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  isDefined,\n} from '@udecode/plate';\n\nimport type { GetSiblingIndentListOptions } from '../queries/getSiblingIndentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { getPreviousIndentList } from '../queries/getPreviousIndentList';\n\nexport const getIndentListExpectedListStart = (\n  entry: NodeEntry,\n  prevEntry?: NodeEntry\n): number => {\n  const [node] = entry;\n  const [prevNode] = prevEntry ?? [null];\n\n  const restart = (node[INDENT_LIST_KEYS.listRestart] as number | null) ?? null;\n  const restartPolite =\n    (node[INDENT_LIST_KEYS.listRestartPolite] as number | null) ?? null;\n\n  if (restart) {\n    return restart;\n  }\n\n  if (restartPolite && !prevNode) {\n    return restartPolite;\n  }\n\n  if (prevNode) {\n    const prevListStart = (prevNode[INDENT_LIST_KEYS.listStart] as number) ?? 1;\n    return prevListStart + 1;\n  }\n\n  return 1;\n};\n\nexport const normalizeIndentListStart = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingIndentListOptions<N, E>>\n) => {\n  return editor.tf.withoutNormalizing(() => {\n    const [node, path] = entry;\n    const listStyleType = (node as any)[BaseIndentListPlugin.key];\n    const listStart = node[INDENT_LIST_KEYS.listStart] as number | undefined;\n\n    if (!listStyleType) return;\n\n    const prevEntry = getPreviousIndentList(editor, entry, options);\n    const expectedListStart = getIndentListExpectedListStart(entry, prevEntry);\n\n    if (isDefined(listStart) && expectedListStart === 1) {\n      editor.tf.unsetNodes(INDENT_LIST_KEYS.listStart, { at: path });\n\n      return true;\n    }\n\n    if (listStart !== expectedListStart && expectedListStart > 1) {\n      editor.tf.setNodes(\n        { [INDENT_LIST_KEYS.listStart]: expectedListStart },\n        { at: path }\n      );\n\n      return true;\n    }\n\n    return false;\n  });\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type GetSiblingIndentListOptions,\n  getSiblingIndentList,\n} from './getSiblingIndentList';\n\n/** Get the previous indent list node. */\nexport const getPreviousIndentList = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingIndentListOptions<N, E>>\n): NodeEntry<N> | undefined => {\n  return getSiblingIndentList(editor, entry, {\n    getPreviousEntry: ([, currPath]) => {\n      const prevPath = PathApi.previous(currPath);\n\n      if (!prevPath) return;\n\n      const prevNode = NodeApi.get<N>(editor, prevPath);\n\n      if (!prevNode) return;\n\n      return [prevNode, prevPath];\n    },\n    ...options,\n    getNextEntry: undefined,\n  });\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type ElementOrTextOf,\n  type NodeEntry,\n  type TNode,\n  isDefined,\n} from '@udecode/plate';\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\nexport interface GetSiblingIndentListOptions<\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n> {\n  breakOnEqIndentNeqListStyleType?: boolean;\n  breakOnListRestart?: boolean;\n  breakOnLowerIndent?: boolean;\n  breakQuery?: (siblingNode: TNode, currentNode: TNode) => boolean | undefined;\n  getNextEntry?: (\n    entry: NodeEntry<ElementOrTextOf<E>>\n  ) => NodeEntry<N> | undefined;\n  getPreviousEntry?: (\n    entry: NodeEntry<ElementOrTextOf<E>>\n  ) => NodeEntry<N> | undefined;\n  /** Query to break lookup */\n  eqIndent?: boolean;\n  /** Query to validate lookup. If false, check the next sibling. */\n  query?: (siblingNode: TNode, currentNode: TNode) => boolean | undefined;\n}\n\n/**\n * Get the next sibling indent list node. Default query: the sibling node should\n * have the same listStyleType.\n */\nexport const getSiblingIndentList = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  [node, path]: ElementEntryOf<E>,\n  {\n    breakOnEqIndentNeqListStyleType = true,\n    breakOnListRestart = false,\n    breakOnLowerIndent = true,\n    breakQuery,\n    eqIndent = true,\n    getNextEntry,\n    getPreviousEntry,\n    query,\n  }: GetSiblingIndentListOptions<N, E>\n): NodeEntry<N> | undefined => {\n  if (!getPreviousEntry && !getNextEntry) return;\n\n  const getSiblingEntry = getNextEntry ?? getPreviousEntry!;\n\n  let nextEntry = getSiblingEntry([node, path]);\n\n  while (true) {\n    if (!nextEntry) return;\n\n    const [nextNode, nextPath] = nextEntry;\n\n    const indent = (node as any)[BaseIndentPlugin.key] as number;\n    const nextIndent = (nextNode as any)[BaseIndentPlugin.key] as number;\n\n    if (breakQuery?.(nextNode, node)) return;\n    if (!isDefined(nextIndent)) return;\n    if (breakOnListRestart) {\n      if (getPreviousEntry && (node as any)[INDENT_LIST_KEYS.listRestart]) {\n        return;\n      }\n      if (getNextEntry && (nextNode as any)[INDENT_LIST_KEYS.listRestart]) {\n        return;\n      }\n    }\n    if (breakOnLowerIndent && nextIndent < indent) return;\n    if (\n      breakOnEqIndentNeqListStyleType &&\n      nextIndent === indent &&\n      (nextNode as any)[BaseIndentListPlugin.key] !==\n        (node as any)[BaseIndentListPlugin.key]\n    )\n      return;\n\n    let valid = !query || query(nextNode, node);\n\n    if (valid) {\n      valid = !eqIndent || nextIndent === indent;\n\n      if (valid) return [nextNode, nextPath];\n    }\n\n    nextEntry = getSiblingEntry(nextEntry);\n  }\n};\n","import { type OverrideEditor, type TElement, isDefined } from '@udecode/plate';\n\nimport { BaseIndentListPlugin } from '../BaseIndentListPlugin';\n\nexport const shouldMergeNodesRemovePrevNodeIndentList: OverrideEditor = ({\n  api: { shouldMergeNodesRemovePrevNode },\n}) => ({\n  api: {\n    shouldMergeNodesRemovePrevNode(prevEntry, curNodeEntry) {\n      const prevNode = prevEntry[0] as TElement;\n      const curNode = curNodeEntry[0] as TElement;\n\n      if (\n        isDefined(curNode[BaseIndentListPlugin.key]) ||\n        isDefined(prevNode[BaseIndentListPlugin.key])\n      ) {\n        return false;\n      }\n\n      return shouldMergeNodesRemovePrevNode(prevEntry, curNodeEntry);\n    },\n  },\n});\n","import { type OverrideEditor, isDefined, NodeApi } from '@udecode/plate';\n\nimport {\n  type BaseIndentListConfig,\n  BaseIndentListPlugin,\n} from '../BaseIndentListPlugin';\nimport { outdentList } from '../transforms';\n\nexport const withDeleteBackwardIndentList: OverrideEditor<\n  BaseIndentListConfig\n> = ({ editor, tf: { deleteBackward } }) => {\n  return {\n    transforms: {\n      deleteBackward(unit) {\n        const nodeEntry = editor.api.above();\n\n        if (!nodeEntry) return deleteBackward(unit);\n\n        const listNode = nodeEntry[0];\n\n        if (editor.api.isCollapsed() && NodeApi.string(listNode))\n          return deleteBackward(unit);\n        if (isDefined(listNode[BaseIndentListPlugin.key])) {\n          return outdentList(editor);\n        }\n\n        return deleteBackward(unit);\n      },\n    },\n  };\n};\n","import type { SlateEditor, TLocation } from '@udecode/plate';\n\nimport { setIndent } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\n\nexport interface IndentListOptions {\n  at?: TLocation;\n  listRestart?: number;\n  listRestartPolite?: number;\n  listStyleType?: ListStyleType | string;\n}\n\n/** Increase the indentation of the selected blocks. */\nexport const indentList = (\n  editor: SlateEditor,\n  { listStyleType = ListStyleType.Disc, ...options }: IndentListOptions = {}\n) => {\n  setIndent(editor, {\n    offset: 1,\n    setNodesProps: () => ({\n      [BaseIndentListPlugin.key]: listStyleType,\n    }),\n    ...options,\n  });\n};\n\nexport const indentTodo = (\n  editor: SlateEditor,\n  { listStyleType = ListStyleType.Disc, ...options }: IndentListOptions = {}\n) => {\n  setIndent(editor, {\n    offset: 1,\n    setNodesProps: () => ({\n      [BaseIndentListPlugin.key]: listStyleType,\n      [INDENT_LIST_KEYS.checked]: false,\n    }),\n    ...options,\n  });\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { setIndent } from '@udecode/plate-indent';\n\nimport type { IndentListOptions } from './indentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\n/** Decrease the indentation of the selected blocks. */\nexport const outdentList = (\n  editor: SlateEditor,\n  options: IndentListOptions = {}\n) => {\n  setIndent(editor, {\n    offset: -1,\n    unsetNodesProps: [BaseIndentListPlugin.key, INDENT_LIST_KEYS.checked],\n    ...options,\n  });\n};\n","import type { Editor, Path } from '@udecode/plate';\n\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\n\nexport const setIndentListNode = (\n  editor: Editor,\n  {\n    at,\n    indent = 0,\n    listStyleType = ListStyleType.Disc,\n  }: {\n    at: Path;\n    indent?: number;\n    listStyleType?: string;\n  }\n) => {\n  const newIndent = indent || indent + 1;\n\n  editor.tf.setNodes(\n    {\n      [BaseIndentListPlugin.key]: listStyleType,\n      [BaseIndentPlugin.key]: newIndent,\n    },\n    { at }\n  );\n};\n\nexport const setIndentTodoNode = (\n  editor: Editor,\n  {\n    at,\n    indent = 0,\n    listStyleType = INDENT_LIST_KEYS.todo,\n  }: {\n    at: Path;\n    indent?: number;\n    listStyleType?: string;\n  }\n) => {\n  const newIndent = indent || indent + 1;\n\n  editor.tf.setNodes(\n    {\n      [BaseIndentListPlugin.key]: listStyleType,\n      [BaseIndentPlugin.key]: newIndent,\n      [INDENT_LIST_KEYS.checked]: false,\n    },\n    { at }\n  );\n};\n","import type { Editor, NodeEntry } from '@udecode/plate';\n\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\nimport { setIndentListNode, setIndentTodoNode } from './setIndentListNode';\n\n/**\n * Set indent list to the given entries. Add indent if listStyleType was not\n * defined.\n */\nexport const setIndentListNodes = (\n  editor: Editor,\n  entries: NodeEntry[],\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    entries.forEach((entry) => {\n      const [node, path] = entry;\n\n      let indent = (node[BaseIndentPlugin.key] as number) ?? 0;\n      indent =\n        node[BaseIndentListPlugin.key] ||\n        node.hasOwnProperty(INDENT_LIST_KEYS.checked)\n          ? indent\n          : indent + 1;\n\n      if (listStyleType === 'todo') {\n        editor.tf.unsetNodes(BaseIndentListPlugin.key, { at: path });\n        setIndentTodoNode(editor, {\n          at: path,\n          indent,\n          listStyleType,\n        });\n\n        return;\n      }\n\n      editor.tf.unsetNodes(INDENT_LIST_KEYS.checked, { at: path });\n      setIndentListNode(editor, {\n        at: path,\n        indent,\n        listStyleType,\n      });\n    });\n  });\n};\n","import type { Editor, ElementEntryOf, ElementOf } from '@udecode/plate';\n\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport type { GetSiblingIndentListOptions } from '../queries/getSiblingIndentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { getIndentListSiblings } from '../queries/getIndentListSiblings';\nimport { ListStyleType } from '../types';\nimport { setIndentListNode, setIndentTodoNode } from './setIndentListNode';\n\n/** Set indent list to entry + siblings. */\nexport const setIndentListSiblingNodes = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  {\n    getSiblingIndentListOptions,\n    listStyleType = ListStyleType.Disc,\n  }: {\n    getSiblingIndentListOptions?: GetSiblingIndentListOptions<N, E>;\n    listStyleType?: string;\n  }\n) => {\n  editor.tf.withoutNormalizing(() => {\n    const siblings = getIndentListSiblings(\n      editor,\n      entry,\n      getSiblingIndentListOptions\n    );\n\n    siblings.forEach(([node, path]) => {\n      if (listStyleType === INDENT_LIST_KEYS.todo) {\n        editor.tf.unsetNodes(BaseIndentListPlugin.key, { at: path });\n        setIndentTodoNode(editor, {\n          at: path,\n          indent: node[BaseIndentPlugin.key] as number,\n          listStyleType,\n        });\n      } else {\n        editor.tf.unsetNodes(INDENT_LIST_KEYS.checked, { at: path });\n        setIndentListNode(editor, {\n          at: path,\n          indent: node[BaseIndentPlugin.key] as number,\n          listStyleType,\n        });\n      }\n    });\n  });\n};\n","import {\n  type Editor,\n  type ElementEntryOf,\n  type ElementOf,\n  type NodeEntry,\n  NodeApi,\n  PathApi,\n} from '@udecode/plate';\n\nimport {\n  type GetSiblingIndentListOptions,\n  getSiblingIndentList,\n} from './getSiblingIndentList';\n\n/** Get the next indent list. */\nexport const getNextIndentList = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  options?: Partial<GetSiblingIndentListOptions<N, E>>\n): NodeEntry<N> | undefined => {\n  return getSiblingIndentList(editor, entry, {\n    getNextEntry: ([, currPath]) => {\n      const nextPath = PathApi.next(currPath);\n      const nextNode = NodeApi.get<N>(editor, nextPath);\n\n      if (!nextNode) return;\n\n      return [nextNode, nextPath];\n    },\n    ...options,\n    getPreviousEntry: undefined,\n  });\n};\n","import type {\n  Editor,\n  ElementEntryOf,\n  ElementOf,\n  NodeEntry,\n  TElement,\n} from '@udecode/plate';\n\nimport type { GetSiblingIndentListOptions } from './getSiblingIndentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { getNextIndentList } from './getNextIndentList';\nimport { getPreviousIndentList } from './getPreviousIndentList';\n\nexport interface GetIndentListSiblingsOptions<\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n> extends Partial<GetSiblingIndentListOptions<N, E>> {\n  current?: boolean;\n  next?: boolean;\n  previous?: boolean;\n}\n\nexport const getIndentListSiblings = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  entry: ElementEntryOf<E>,\n  {\n    current = true,\n    next = true,\n    previous = true,\n    ...options\n  }: GetIndentListSiblingsOptions<N, E> = {}\n) => {\n  const siblings: NodeEntry[] = [];\n\n  const node = entry[0] as TElement;\n\n  // if (!(node as any)[IndentListPlugin.key]) return siblings;\n  if (\n    !node[BaseIndentListPlugin.key] &&\n    !node.hasOwnProperty(INDENT_LIST_KEYS.checked)\n  ) {\n    return siblings;\n  }\n\n  let iterEntry = entry;\n\n  if (previous) {\n    while (true) {\n      const prevEntry = getPreviousIndentList<N, E>(editor, iterEntry, options);\n\n      if (!prevEntry) break;\n\n      siblings.push(prevEntry);\n\n      iterEntry = prevEntry;\n    }\n  }\n  if (current) {\n    siblings.push(entry);\n  }\n  if (next) {\n    iterEntry = entry;\n\n    while (true) {\n      const nextEntry = getNextIndentList(editor, iterEntry, options);\n\n      if (!nextEntry) break;\n\n      siblings.push(nextEntry);\n\n      iterEntry = nextEntry;\n    }\n  }\n\n  return siblings;\n};\n","import type {\n  ElementEntryOf,\n  ElementOf,\n  SlateEditor,\n  TElement,\n} from '@udecode/plate';\n\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport type { IndentListOptions } from './indentList';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport {\n  type GetSiblingIndentListOptions,\n  getIndentListAbove,\n  getPreviousIndentList,\n} from '../queries';\nimport { areEqListStyleType } from '../queries/areEqListStyleType';\nimport { setIndentListNodes } from './setIndentListNodes';\nimport { setIndentListSiblingNodes } from './setIndentListSiblingNodes';\nimport { toggleIndentListSet } from './toggleIndentListSet';\nimport { toggleIndentListUnset } from './toggleIndentListUnset';\n\n/** Toggle indent list. */\nexport const toggleIndentList = <\n  N extends ElementOf<E>,\n  E extends SlateEditor = SlateEditor,\n>(\n  editor: E,\n  options: IndentListOptions,\n  getSiblingIndentListOptions?: GetSiblingIndentListOptions<N, E>\n) => {\n  const { listRestart, listRestartPolite, listStyleType } = options;\n\n  /**\n   * True - One or more blocks were converted to lists or changed such that they\n   * remain lists.\n   *\n   * False - One or more list blocks were unset.\n   *\n   * Null - No action was taken.\n   */\n  const setIndentList = ((): boolean | null => {\n    const { getSiblingIndentListOptions: _getSiblingIndentListOptions } =\n      editor.getOptions(BaseIndentListPlugin);\n\n    if (editor.api.isCollapsed()) {\n      const entry = editor.api.block<TElement>();\n\n      if (!entry) return null;\n      if (toggleIndentListSet(editor, entry, options)) {\n        return true;\n      }\n      if (toggleIndentListUnset(editor, entry, { listStyleType })) {\n        return false;\n      }\n\n      setIndentListSiblingNodes(editor, entry as ElementEntryOf<E>, {\n        getSiblingIndentListOptions: {\n          ..._getSiblingIndentListOptions,\n          ...getSiblingIndentListOptions,\n        } as GetSiblingIndentListOptions<ElementOf<E>, E>,\n        listStyleType,\n      });\n\n      return true;\n    }\n    if (editor.api.isExpanded()) {\n      const _entries = editor.api.nodes<TElement>({ block: true });\n      const entries = [..._entries];\n\n      const eqListStyleType = areEqListStyleType(editor, entries, {\n        listStyleType,\n      });\n\n      if (eqListStyleType) {\n        editor.tf.withoutNormalizing(() => {\n          entries.forEach((entry) => {\n            const [node, path] = entry;\n\n            const indent = node[BaseIndentPlugin.key] as number;\n\n            editor.tf.unsetNodes(BaseIndentListPlugin.key, { at: path });\n\n            if (indent > 1) {\n              editor.tf.setNodes(\n                { [BaseIndentPlugin.key]: indent - 1 },\n                { at: path }\n              );\n            } else {\n              editor.tf.unsetNodes(\n                [BaseIndentPlugin.key, INDENT_LIST_KEYS.checked],\n                {\n                  at: path,\n                }\n              );\n            }\n            // setIndentListNode(editor, {\n            //   listStyleType,\n            //   indent: node[BaseIndentPlugin.key],\n            //   at: path,\n            // });\n          });\n        });\n\n        return false;\n      }\n\n      setIndentListNodes(editor, entries, { listStyleType });\n      return true;\n    }\n\n    return null;\n  })();\n\n  // Apply listRestart or listRestartPolite if applicable\n  const restartValue = listRestart || listRestartPolite;\n  const isRestart = !!listRestart;\n\n  if (setIndentList && restartValue) {\n    const atStart = editor.api.start(editor.selection!);\n    const entry = getIndentListAbove(editor, { at: atStart });\n    if (!entry) return;\n\n    const isFirst = !getPreviousIndentList(editor, entry);\n\n    /**\n     * Only apply listRestartPolite if this is the first item and restartValue >\n     * 1.\n     */\n    if (!isRestart && (!isFirst || restartValue <= 0)) return;\n\n    // If restartValue is 1, only apply listRestart if this is not the first\n    if (isRestart && restartValue === 1 && isFirst) return;\n\n    const prop = isRestart\n      ? INDENT_LIST_KEYS.listRestart\n      : INDENT_LIST_KEYS.listRestartPolite;\n\n    editor.tf.setNodes({ [prop]: restartValue }, { at: entry[1] });\n  }\n};\n","import type { Editor, NodeEntry } from '@udecode/plate';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\n\nexport const areEqListStyleType = (\n  editor: Editor,\n  entries: NodeEntry[],\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  let eqListStyleType = true;\n\n  for (const entry of entries) {\n    const [block] = entry;\n\n    if (listStyleType === INDENT_LIST_KEYS.todo) {\n      if (!block.hasOwnProperty(INDENT_LIST_KEYS.checked)) {\n        eqListStyleType = false;\n\n        break;\n      }\n\n      continue;\n    }\n    if (\n      !block[BaseIndentListPlugin.key] ||\n      block[BaseIndentListPlugin.key] !== listStyleType\n    ) {\n      eqListStyleType = false;\n\n      break;\n    }\n  }\n\n  return eqListStyleType;\n};\n","import {\n  type Editor,\n  type EditorAboveOptions,\n  type ElementOf,\n  type NodeEntry,\n  isDefined,\n} from '@udecode/plate';\n\nimport { BaseIndentListPlugin } from '../BaseIndentListPlugin';\n\nexport const getIndentListAbove = <\n  N extends ElementOf<E>,\n  E extends Editor = Editor,\n>(\n  editor: E,\n  options?: Omit<EditorAboveOptions, 'match'>\n): NodeEntry<N> | undefined => {\n  return editor.api.above({\n    ...options,\n    match: (node) => isDefined(node[BaseIndentListPlugin.key]),\n  });\n};\n","import type {\n  ElementOf,\n  NodeEntry,\n  SlateEditor,\n  TElement,\n} from '@udecode/plate';\n\nimport type { ListStyleType } from '../types';\n\nimport { BaseIndentListPlugin } from '../BaseIndentListPlugin';\nimport {\n  type GetIndentListSiblingsOptions,\n  getIndentListSiblings,\n} from './index';\n\n/**\n * Get the first sibling list style type at the given indent. If none, return\n * the entry list style type.\n */\nexport const getSiblingListStyleType = <E extends SlateEditor>(\n  editor: E,\n  {\n    entry,\n    indent,\n    ...options\n  }: {\n    entry: NodeEntry<TElement>;\n    indent: number;\n  } & GetIndentListSiblingsOptions<ElementOf<E>, E>\n) => {\n  const siblingEntry: NodeEntry<TElement> = [{ ...entry[0], indent }, entry[1]];\n\n  const siblings = getIndentListSiblings(editor, siblingEntry as any, {\n    breakOnEqIndentNeqListStyleType: false,\n    current: false,\n    eqIndent: true,\n    ...options,\n  });\n\n  return (\n    siblings.length > 0\n      ? siblings[0][0][BaseIndentListPlugin.key]\n      : entry[0][BaseIndentListPlugin.key]\n  ) as ListStyleType;\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { BaseIndentListPlugin, INDENT_LIST_KEYS } from '../../index';\n\nexport const someIndentList = (\n  editor: SlateEditor,\n  type: string[] | string\n) => {\n  return (\n    !!editor.selection &&\n    editor.api.some({\n      match: (n: any) => {\n        const isHasProperty = n.hasOwnProperty(INDENT_LIST_KEYS.checked);\n\n        if (isHasProperty) {\n          return false;\n        }\n\n        const list = n[BaseIndentListPlugin.key];\n\n        return Array.isArray(type) ? type.includes(list) : list === type;\n      },\n    })\n  );\n};\n","import type { SlateEditor } from '@udecode/plate';\n\nimport { BaseIndentListPlugin, INDENT_LIST_KEYS } from '../../index';\n\nexport const someIndentTodo = (editor: SlateEditor) => {\n  return editor.api.some({\n    at: editor.selection!,\n    match: (n) => {\n      const list = n[BaseIndentListPlugin.key];\n      const isHasProperty = n.hasOwnProperty(INDENT_LIST_KEYS.checked);\n\n      return n.type === 'p' && isHasProperty && list === INDENT_LIST_KEYS.todo;\n    },\n  });\n};\n","import type { Editor, NodeEntry } from '@udecode/plate';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\nimport { type IndentListOptions, indentList, indentTodo } from './indentList';\n\n/** Set indent list if not set. */\nexport const toggleIndentListSet = (\n  editor: Editor,\n  [node, _path]: NodeEntry,\n  { listStyleType = ListStyleType.Disc, ...options }: IndentListOptions\n) => {\n  if (\n    node.hasOwnProperty(INDENT_LIST_KEYS.checked) ||\n    node[BaseIndentListPlugin.key]\n  )\n    return;\n  if (listStyleType === 'todo') {\n    indentTodo(editor as any, {\n      listStyleType,\n      ...options,\n    });\n  } else {\n    indentList(editor as any, {\n      listStyleType,\n      ...options,\n    });\n  }\n\n  return true;\n};\n","import type { Editor, NodeEntry } from '@udecode/plate';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\nimport { ListStyleType } from '../types';\nimport { outdentList } from './outdentList';\n\n/** Unset list style type if already set. */\nexport const toggleIndentListUnset = (\n  editor: Editor,\n  [node, path]: NodeEntry,\n  {\n    listStyleType = ListStyleType.Disc,\n  }: {\n    listStyleType?: string;\n  }\n) => {\n  if (\n    listStyleType === INDENT_LIST_KEYS.todo &&\n    node.hasOwnProperty(INDENT_LIST_KEYS.checked)\n  ) {\n    editor.tf.unsetNodes(INDENT_LIST_KEYS.checked, { at: path });\n    outdentList(editor as any, { listStyleType });\n\n    return true;\n  }\n  if (listStyleType === node[BaseIndentListPlugin.key]) {\n    editor.tf.unsetNodes([BaseIndentListPlugin.key], {\n      at: path,\n    });\n\n    outdentList(editor as any, { listStyleType });\n\n    return true;\n  }\n};\n","import {\n  type NodeEntry,\n  type SlateEditor,\n  BaseParagraphPlugin,\n} from '@udecode/plate';\nimport { BaseIndentPlugin } from '@udecode/plate-indent';\n\nimport {\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\nexport const toggleIndentListByPath = (\n  editor: SlateEditor,\n  [node, path]: NodeEntry,\n  listStyleType: string\n) => {\n  editor.tf.setNodes(\n    {\n      [BaseIndentListPlugin.key]: listStyleType,\n      [BaseIndentPlugin.key]: node.indent ?? 1,\n      // TODO: normalized if not todo remove this property.\n      [INDENT_LIST_KEYS.checked]: false,\n      type: BaseParagraphPlugin.key,\n    },\n    {\n      at: path,\n    }\n  );\n};\n\nexport const toggleIndentListByPathUnSet = (\n  editor: SlateEditor,\n  [, path]: NodeEntry\n) =>\n  editor.tf.unsetNodes(\n    [BaseIndentListPlugin.key, BaseIndentPlugin.key, INDENT_LIST_KEYS.checked],\n    {\n      at: path,\n    }\n  );\n","import { type OverrideEditor, type TElement, isDefined } from '@udecode/plate';\n\nimport {\n  type BaseIndentListConfig,\n  BaseIndentListPlugin,\n  INDENT_LIST_KEYS,\n} from '../BaseIndentListPlugin';\n\nexport const withInsertBreakIndentList: OverrideEditor<\n  BaseIndentListConfig\n> = ({ editor, tf: { insertBreak } }) => {\n  return {\n    transforms: {\n      insertBreak() {\n        const nodeEntry = editor.api.above();\n\n        if (!nodeEntry) return insertBreak();\n\n        const [node, path] = nodeEntry;\n\n        if (\n          !isDefined(node[BaseIndentListPlugin.key]) ||\n          node[BaseIndentListPlugin.key] !== INDENT_LIST_KEYS.todo ||\n          editor.api.isExpanded() ||\n          !editor.api.isEnd(editor.selection?.focus, path)\n        ) {\n          return insertBreak();\n        }\n\n        editor.tf.withoutNormalizing(() => {\n          insertBreak();\n\n          const newEntry = editor.api.above<TElement>();\n\n          if (newEntry) {\n            editor.tf.setNodes(\n              {\n                checked: false,\n              },\n              { at: newEntry[1] }\n            );\n          }\n        });\n      },\n    },\n  };\n};\n","import type { OverrideEditor, TElement } from '@udecode/plate';\n\nimport type { BaseIndentListConfig } from './BaseIndentListPlugin';\n\nimport { normalizeIndentListNotIndented } from './normalizers/normalizeIndentListNotIndented';\nimport { normalizeIndentListStart } from './normalizers/normalizeIndentListStart';\n\nexport const withNormalizeIndentList: OverrideEditor<BaseIndentListConfig> = ({\n  editor,\n  getOptions,\n  tf: { normalizeNode },\n}) => {\n  return {\n    transforms: {\n      normalizeNode([node, path]) {\n        const normalized = editor.tf.withoutNormalizing(() => {\n          if (normalizeIndentListNotIndented(editor, [node, path])) return true;\n          if (\n            normalizeIndentListStart(\n              editor,\n              [node as TElement, path],\n              getOptions().getSiblingIndentListOptions\n            )\n          )\n            return true;\n        });\n\n        if (normalized) return;\n\n        return normalizeNode([node, path]);\n      },\n    },\n  };\n};\n"],"mappings":"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","names":["import_plate","ListStyleType","React","import_plate","import_plate","import_plate","import_plate","import_plate_indent","import_plate","import_plate","import_plate_indent","import_plate_indent","import_plate_indent","import_plate_indent","import_plate_indent","import_plate","import_plate_indent","import_plate","import_plate","import_plate_indent","import_plate"]}