var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/cache/node-cache.ts
var node_cache_exports = {};
__export(node_cache_exports, {
  NodeCache: () => NodeCache,
  makeCacheDir: () => makeCacheDir
});
var resolveModule, getRootPath, makeCacheDir, NodeCache;
var init_node_cache = __esm({
  "src/cache/node-cache.ts"() {
    resolveModule = (mod) => {
      if (mod && typeof mod === "object" && "default" in mod && mod.default) {
        return mod.default;
      }
      return mod;
    };
    getRootPath = (pathParts, pathArg) => {
      if (pathParts.length === 0) return null;
      const isWindows = pathArg.sep === "\\";
      const root = pathParts[0];
      return isWindows ? `${root}${pathArg.sep}` : `${pathArg.sep}${root}`;
    };
    makeCacheDir = (dir, fsArg, pathArg, osArg) => {
      const normalizedDir = pathArg.normalize(dir);
      const pathParts = normalizedDir.split(pathArg.sep).filter(Boolean);
      const cacheHash = pathParts[pathParts.length - 1];
      const rootPath = getRootPath(pathParts, pathArg);
      const rootExists = rootPath && fsArg.existsSync(rootPath);
      const cacheDir = rootExists ? normalizedDir : pathArg.join(osArg.tmpdir(), cacheHash);
      try {
        fsArg.mkdirSync(cacheDir, { recursive: true });
      } catch (error) {
        console.warn(
          `Warning: Failed to create cache directory: ${error.message}. Caching will be disabled.`
        );
        return null;
      }
      return cacheDir;
    };
    NodeCache = async (dir) => {
      try {
        const [fsModule, pathModule, osModule, cryptoModule] = await Promise.all([
          import("node:fs"),
          import("node:path"),
          import("node:os"),
          import("node:crypto")
        ]);
        const fs = resolveModule(fsModule);
        const path = resolveModule(pathModule);
        const os = resolveModule(osModule);
        const crypto = resolveModule(cryptoModule);
        if (typeof path?.join !== "function") {
          console.warn(
            "Warning: Node.js path module not available. Caching will be disabled."
          );
          return null;
        }
        const cacheDir = makeCacheDir(dir, fs, path, os);
        if (cacheDir === null) {
          return null;
        }
        return {
          makeKey: (key) => {
            const input = key && key instanceof Object ? JSON.stringify(key) : key || "";
            return crypto.createHash("sha256").update(input).digest("hex");
          },
          get: async (key) => {
            let readValue;
            const cacheFilename = path.join(cacheDir, key);
            try {
              const data = await fs.promises.readFile(cacheFilename, "utf-8");
              readValue = JSON.parse(data);
            } catch (e) {
              if (e.code !== "ENOENT") {
                console.warn(
                  `Warning: Failed to read cache file ${cacheFilename}: ${e.message}`
                );
              }
            }
            return readValue;
          },
          set: async (key, value) => {
            const cacheFilename = path.join(cacheDir, key);
            try {
              await fs.promises.writeFile(cacheFilename, JSON.stringify(value), {
                encoding: "utf-8",
                flag: "wx"
              });
            } catch (e) {
              if (e.code !== "EEXIST") {
                console.warn(
                  `Warning: Failed to write cache file ${cacheFilename}: ${e.message}`
                );
              }
            }
          }
        };
      } catch (e) {
        console.warn(
          "Warning: Failed to initialize cache. Caching will be disabled.",
          e.message
        );
        return null;
      }
    };
  }
});

// src/unifiedClient/index.ts
import AsyncLock from "async-lock";
var TINA_HOST = "content.tinajs.io";
function replaceGithubPathSplit(url, replacement) {
  const parts = url.split("github/");
  if (parts.length > 1 && replacement) {
    return parts[0] + "github/" + replacement;
  } else {
    return url;
  }
}
var TinaClient = class {
  apiUrl;
  readonlyToken;
  queries;
  errorPolicy;
  initialized = false;
  cacheLock;
  cacheDir;
  cache;
  constructor({
    token,
    url,
    queries,
    errorPolicy,
    cacheDir
  }) {
    this.apiUrl = url;
    this.readonlyToken = token?.trim();
    this.queries = queries(this);
    this.errorPolicy = errorPolicy || "throw";
    this.cacheDir = cacheDir || "";
  }
  async init() {
    if (this.initialized) {
      return;
    }
    try {
      if (this.cacheDir && typeof window === "undefined") {
        const { NodeCache: NodeCache2 } = await Promise.resolve().then(() => (init_node_cache(), node_cache_exports));
        this.cache = await NodeCache2(this.cacheDir);
        if (this.cache) {
          this.cacheLock = new AsyncLock();
        }
      }
    } catch (e) {
      console.error(e);
    }
    this.initialized = true;
  }
  async request({ errorPolicy, ...args }, options) {
    await this.init();
    const errorPolicyDefined = errorPolicy || this.errorPolicy;
    const headers = new Headers();
    if (this.readonlyToken) {
      headers.append("X-API-KEY", this.readonlyToken);
    }
    headers.append("Content-Type", "application/json");
    if (options?.fetchOptions) {
      if (options?.fetchOptions?.headers) {
        Object.entries(options.fetchOptions.headers).forEach(([key2, value]) => {
          headers.append(key2, value);
        });
      }
    }
    const { headers: _, ...providedFetchOptions } = options?.fetchOptions || {};
    const bodyString = JSON.stringify({
      query: args.query,
      variables: args?.variables || {}
    });
    const optionsObject = {
      method: "POST",
      headers,
      body: bodyString,
      redirect: "follow",
      ...providedFetchOptions
    };
    const draftBranch = headers.get("x-branch");
    const url = replaceGithubPathSplit(args?.url || this.apiUrl, draftBranch);
    let key = "";
    let result;
    if (this.cache) {
      key = this.cache.makeKey(bodyString);
      await this.cacheLock.acquire(key, async () => {
        result = await this.cache.get(key);
        if (!result) {
          result = await requestFromServer(
            url,
            args.query,
            optionsObject,
            errorPolicyDefined
          );
          await this.cache.set(key, result);
        }
      });
    } else {
      result = await requestFromServer(
        url,
        args.query,
        optionsObject,
        errorPolicyDefined
      );
    }
    return result;
  }
};
async function requestFromServer(url, query, optionsObject, errorPolicyDefined) {
  const res = await fetch(url, optionsObject);
  if (!res.ok) {
    let additionalInfo = "";
    if (res.status === 401) {
      additionalInfo = "Please check that your client ID, URL and read only token are configured properly.";
    }
    throw new Error(
      `Server responded with status code ${res.status}, ${res.statusText}. ${additionalInfo ? additionalInfo : ""} Please see our FAQ for more information: https://tina.io/docs/r/FAQ/`
    );
  }
  const json = await res.json();
  if (json.errors && errorPolicyDefined === "throw") {
    throw new Error(
      `Unable to fetch, please see our FAQ for more information: https://tina.io/docs/r/FAQ/
      Errors: 
	${json.errors.map((error) => error.message).join("\n")}`
    );
  }
  const result = {
    data: json?.data,
    errors: json?.errors || null,
    query
  };
  return result;
}
function createClient(args) {
  const client = new TinaClient(args);
  return client;
}
export {
  TINA_HOST,
  TinaClient,
  createClient
};
