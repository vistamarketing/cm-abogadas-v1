var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as sw from "stopword";
const INDEXABLE_NODE_TYPES = ["text", "code_block", "html"];
class StringBuilder {
  constructor(limit) {
    __publicField(this, "buffer", []);
    __publicField(this, "limit");
    __publicField(this, "length", 0);
    this.limit = limit;
  }
  append(str) {
    if (this.length + str.length > this.limit)
      return true;
    this.buffer.push(str);
    this.length += str.length;
    return this.length > this.limit;
  }
  toString() {
    return this.buffer.join(" ");
  }
}
const tokenizeString = (str) => {
  return str.split(/[\s\.,]+/).map((s) => s.toLowerCase()).filter((s) => s);
};
const extractText = (data, builder, nodeTypes) => {
  var _a;
  if (!data)
    return;
  if (nodeTypes.includes(data.type ?? "") && (data.text || data.value)) {
    const tokens = tokenizeString(data.text || data.value || "");
    for (const token of tokens) {
      if (builder.append(token))
        return;
    }
  }
  (_a = data.children) == null ? void 0 : _a.forEach((child) => extractText(child, builder, nodeTypes));
};
const getRelativePath = (path, collection) => {
  return path.replace(/\\/g, "/").replace(collection.path, "").replace(/^\/|\/$/g, "");
};
const processTextField = (value, maxLength) => {
  const tokens = tokenizeString(value);
  const builder = new StringBuilder(maxLength);
  for (const part of tokens) {
    if (builder.append(part))
      break;
  }
  return builder.toString();
};
const processRichTextField = (value, maxLength) => {
  const builder = new StringBuilder(maxLength);
  extractText(value, builder, INDEXABLE_NODE_TYPES);
  return builder.toString();
};
const processObjectField = (data, path, collection, textIndexLength, field) => {
  if (field.list) {
    return data.map(
      (obj) => processDocumentForIndexing(obj, path, collection, textIndexLength, field)
    );
  }
  return processDocumentForIndexing(
    data,
    path,
    collection,
    textIndexLength,
    field
  );
};
const processStringField = (data, maxLength, isList) => {
  if (isList) {
    return data.map(
      (value) => processTextField(value, maxLength)
    );
  }
  return processTextField(data, maxLength);
};
const processRichTextFieldData = (data, maxLength, isList) => {
  if (isList) {
    return data.map(
      (value) => processRichTextField(value, maxLength)
    );
  }
  return processRichTextField(data, maxLength);
};
const processDocumentForIndexing = (data, path, collection, textIndexLength, field) => {
  if (!field) {
    const relativePath = getRelativePath(path, collection);
    data["_id"] = `${collection.name}:${relativePath}`;
    data["_relativePath"] = relativePath;
  }
  const fields = (field == null ? void 0 : field.fields) || collection.fields || [];
  for (const f of fields) {
    if (!f.searchable) {
      delete data[f.name];
      continue;
    }
    if (!data[f.name])
      continue;
    const fieldMaxLength = f.maxSearchIndexFieldLength || textIndexLength;
    const isList = Boolean(f.list);
    switch (f.type) {
      case "object":
        data[f.name] = processObjectField(
          data[f.name],
          path,
          collection,
          textIndexLength,
          f
        );
        break;
      case "string":
        data[f.name] = processStringField(
          data[f.name],
          fieldMaxLength,
          isList
        );
        break;
      case "rich-text":
        data[f.name] = processRichTextFieldData(
          data[f.name],
          fieldMaxLength,
          isList
        );
        break;
    }
  }
  return data;
};
const stopwordCache = {};
const lookupStopwords = (keys, defaultStopWords = sw.eng) => {
  if (!keys) {
    return defaultStopWords;
  }
  const cacheKey = keys.join(",");
  if (stopwordCache[cacheKey]) {
    return stopwordCache[cacheKey];
  }
  const stopwords = keys.flatMap((key) => sw[key] || []);
  stopwordCache[cacheKey] = stopwords;
  return stopwords;
};
const queryToSearchIndexQuery = (query, stopwordLanguages) => {
  const parts = query.split(" ");
  const stopwords = lookupStopwords(stopwordLanguages);
  if (parts.length === 1) {
    return { AND: [parts[0]] };
  }
  const filteredParts = parts.filter(
    (part) => part.toLowerCase() !== "and" && !stopwords.includes(part.toLowerCase())
  );
  return { AND: filteredParts };
};
const optionsToSearchIndexOptions = (options) => {
  if (!(options == null ? void 0 : options.limit))
    return {};
  return {
    PAGE: {
      SIZE: options.limit,
      NUMBER: options.cursor ? parseInt(options.cursor) : 0
    }
  };
};
const parseSearchIndexResponse = (data, options) => {
  const resultArray = (data == null ? void 0 : data.RESULT) ?? (data == null ? void 0 : data.results);
  if (!data || !Array.isArray(resultArray)) {
    return {
      results: [],
      total: 0,
      prevCursor: null,
      nextCursor: null,
      fuzzyMatches: void 0
    };
  }
  const results = data.RESULT ?? data.results;
  const total = data.RESULT_LENGTH ?? data.total ?? 0;
  const fuzzyMatches = data.FUZZY_MATCHES ?? data.fuzzyMatches;
  const nextCursor = data.NEXT_CURSOR ?? data.nextCursor;
  const prevCursor = data.PREV_CURSOR ?? data.prevCursor;
  if (nextCursor !== void 0 || prevCursor !== void 0) {
    return {
      results,
      total,
      prevCursor: prevCursor ?? null,
      nextCursor: nextCursor ?? null,
      fuzzyMatches
    };
  }
  const currentPage = (options == null ? void 0 : options.cursor) ? parseInt(options.cursor) : 0;
  const pageSize = options == null ? void 0 : options.limit;
  const hasPreviousPage = currentPage > 0;
  const hasNextPage = pageSize ? total > (currentPage + 1) * pageSize : false;
  return {
    results,
    total,
    prevCursor: hasPreviousPage ? (currentPage - 1).toString() : null,
    nextCursor: hasNextPage ? (currentPage + 1).toString() : null,
    fuzzyMatches
  };
};
export {
  optionsToSearchIndexOptions,
  parseSearchIndexResponse,
  processDocumentForIndexing,
  queryToSearchIndexQuery
};
